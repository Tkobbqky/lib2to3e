实战Java虚拟机-JVM故障诊断与性能优化 PDF下载 葛一鸣 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712125612
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712125612
<p>书名:实战Java虚拟机-JVM故障诊断与性能优化</p><p>作者:葛一鸣</p><p>页数:436</p><p>定价:¥79.0</p><p>出版社:电子工业出版社</p><p>出版日期:2015-03-01</p><p>ISBN:9787121256127</p><p><h2>相关资料</h2></p>[<p>    对java程序员来说，java虚拟机（jvm）可以说是既熟悉又神秘，很少有java程序员能够抑制自己探究它的冲动。可惜分析jvm故障诊断与性能优化的书籍（尤其是国内出版的）简直少之又少。本书的出版可谓研究jvm的程序员的福音，作者注重理论联系实际，对于理论性较强的章节和知识点安排了大量的实践案例来说明和进行实际操作，具有非常强的实践指导意义。同时本书配套操作视频《深入浅出java虚拟机——入门篇》在51cto学院独家发布后受到了51cto社区广大开发者和爱好者的好评和认可，所以，强烈推荐本书给爱好jvm的你！<br/>
    ——51cto学院高级运营经理 曹亚莉<br/></p>]<p><h2>本书特色</h2></p>[<p>
    随着越来越多的第三方语言（groovy、scala、jruby等）在java虚拟机上运行，java也俨然成为一个充满活力的生态圈。本书将通过200余示例详细介绍java虚拟机中的各种参数配置、故障排查、性能监控以及性能优化。
    本书共11章。第1~3章介绍了java虚拟机的定义、总体架构、常用配置参数。第4~5章介绍了垃圾回收的算法和各种垃圾回收器。第6章介绍了虚拟机的性能监控和故障诊断工具。第7章详细介绍了对java堆的分析方法和案例。第8章介绍了java虚拟机对多线程，尤其是锁的支持。第9~10章介绍了虚拟机的核心——class文件结构，以及虚拟机中类的装载系统。第11章介绍了虚拟机的执行系统和字节码，并给出了通过asm框架进行字节码注入的案例。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书的主要特点有：
1. 结构清晰。步步为营，每一章节对应一个单独的知识点，力求展示虚拟机的全貌。
2. 理论结合实战。在每一个理论背后，都给出了演示示例供读者参考。
3. 专注专业。包括但不限于体系结构、虚拟机的调试方式、常用参数、垃圾回收系统、class文件结构、执行系统等，力求从多角度更专业地对java虚拟机进行探讨。
4. 通俗易懂。简单的白话文风格贯穿全书，尽量做到读者在阅读过程中少盲点、无盲点。
5. 技术全面。纵横windows和linux双系统下的性能诊断、涉及32位系统和64位系统的优化比较、贯穿从jdk 1.5到jdk 1.8的优化演进。</p>]<p><h2>作者简介</h2></p>[<p>    葛一鸣，51CTO特约讲师，国家认证系统分析师，获得Oracle OCP认证。长期从事Java软件开发工作，对Java程序设计、JVM有深入的研究，对设计模式、人工智能、神经网络、数据挖掘等技术有浓厚兴趣，著有《自己动手写神经网路》电子书，也开设了在线的《深入浅出Java虚拟机——入门篇》培训课程。</p>]<p><h2>目录</h2></p>
    第1章　初探java虚拟机 11.1  知根知底：追溯java的发展历程 21.1.1  那些依托java虚拟机的语言大咖们 21.1.2  java发展史上的里程碑 21.2  跨平台的真相：java虚拟机来做中介 41.2.1  理解java虚拟机的原理 41.2.2  看清java虚拟机的种类 51.3  一切看我的：java语言规范 61.3.1  词法的定义 61.3.2  语法的定义 71.3.3  数据类型的定义 81.3.4  java语言规范总结 91.4  一切听我的：java虚拟机规范 91.5  数字编码就是计算机世界的水和电 101.5.1  整数在java虚拟机中的表示 101.5.2  浮点数在java虚拟机中的表示 121.6  抛砖引玉：编译和调试虚拟机 141.7  小结 19第2章　认识java虚拟机的基本结构 202.1  谋全局者才能成大器：看穿java虚拟机的架构 202.2  小参数能解决大问题：学会设置java虚拟机的参数 222.3  对象去哪儿：辨清java堆 232.4  函数如何调用：出入java栈 252.4.1  局部变量表 272.4.2  操作数栈 322.4.3  帧数据区 322.4.4  栈上分配 332.5  类去哪儿了：识别方法区 352.6  小结 37第3章　常用java虚拟机参数 383.1  一切运行都有迹可循：掌握跟踪调试参数 383.1.1  跟踪垃圾回收——读懂虚拟机日志 393.1.2  类加载/卸载的跟踪 423.1.3  系统参数查看 443.2  让性能飞起来：学习堆的配置参数 453.2.1  *大堆和初始堆的设置 453.2.2  新生代的配置 493.2.3  堆溢出处理 523.3  别让性能有缺口：了解非堆内存的参数配置 543.3.1  方法区配置 553.3.2  栈配置 553.3.3  直接内存配置 553.4  client和server二选一：虚拟机的工作模式 583.5  小结 59第4章　垃圾回收概念与算法 604.1  内存管理清洁工：认识垃圾回收 604.2  清洁工具大pk：讨论常用的垃圾回收算法 614.2.1  引用计数法（reference counting） 624.2.2  标记清除法（mark-sweep） 634.2.3  复制算法（copying） 644.2.4  标记压缩法（mark-compact） 664.2.5  分代算法（generational collecting） 674.2.6  分区算法（region） 684.3  谁才是真正的垃圾：判断可触及性 694.3.1  对象的复活 694.3.2  引用和可触及性的强度 714.3.3  软引用——可被回收的引用 724.3.4  弱引用——发现即回收 764.3.5  虚引用——对象回收跟踪 774.4  垃圾回收时的停顿现象：stop-the-world案例实战 794.5  小结 83第5章　垃圾收集器和内存分配 845.1  一心一意一件事：串行回收器 855.1.1  新生代串行回收器 855.1.2  老年代串行回收器 865.2  人多力量大：并行回收器 865.2.1  新生代parnew回收器 875.2.2  新生代parallelgc回收器 885.2.2  老年代paralleloldgc回收器 895.3  一心多用都不落下：cms回收器 905.3.1  cms主要工作步骤 905.3.2  cms主要的设置参数 915.3.3  cms的日志分析 925.3.4  有关class的回收 945.4  未来我做主：g1回收器 955.4.1  g1的内存划分和主要收集过程 955.4.2  g1的新生代gc 965.4.3  g1的并发标记周期 975.4.4  混合回收 1005.4.5  必要时的full gc 1025.4.6  g1日志 1025.4.7  g1相关的参数 1065.5  回眸：有关对象内存分配和回收的一些细节问题 1075.5.1  禁用system.gc() 1075.5.2  system.gc()使用并发回收 1075.5.3  并行gc前额外触发的新生代gc 1095.5.4  对象何时进入老年代 1105.5.5  在tlab上分配对象 1175.5.6  方法finalize()对垃圾回收的影响 1205.6  温故又知新：常用的gc参数 1255.7  动手才是真英雄：垃圾回收器对tomcat性能影响的实验 1275.7.1  配置实验环境 1275.7.2  配置进行性能测试的工具jmeter 1285.7.3  配置web应用服务器tomcat 1315.7.4  实战案例1——初试串行回收器 1335.7.5  实战案例2——扩大堆以提升系统性能 1335.7.6  实战案例3——调整初始堆大小 1345.7.7  实战案例4——使用parrelloldgc回收器 1355.7.8  实战案例5——使用较小堆提高gc压力 1355.7.9  实战案例6——测试paralleloldgc的表现 1355.7.10 实战案例7——测试parnew回收器的表现 1365.7.11 实战案例8——测试jdk 1.6的表现 1365.7.12 实验9——使用高版本虚拟机提升性能 1375.8  小结 137第6章　性能监控工具 1386.1  有我更高效：linux下的性能监控工具 1396.1.1  显示系统整体资源使用情况——top命令 1396.1.2  监控内存和cpu——vmstat命令 1406.1.3  监控io使用——iostat命令 1426.1.4  多功能诊断器——pidstat工具 1436.2  用我更高效：windows下的性能监控工具 1486.2.1  任务管理器 1486.2.2  perfmon性能监控工具 1506.2.3  process explorer进程管理工具 1536.2.4  pslist命令——windows下也有命令行工具 1556.3  外科手术刀：jdk性能监控工具 1576.3.1  查看java进程——jps命令 1586.3.2  查看虚拟机运行时信息——jstat命令 1596.3.3  查看虚拟机参数——jinfo命令 1626.3.4  导出堆到文件——jmap命令 1636.3.5  jdk自带的堆分析工具——jhat命令 1656.3.6  查看线程堆栈——jstack命令 1676.3.7  远程主机信息收集——jstatd命令 1706.3.8  多功能命令行——jcmd命令 1726.3.9  性能统计工具——hprof 1756.3.10 扩展jps命令 1776.4  我是你的眼：图形化虚拟机监控工具jconsole 1786.4.1  jconsole连接java程序 1786.4.2  java程序概况 1796.4.3  内存监控 1806.4.4  线程监控 1806.4.5  类加载情况 1826.4.6  虚拟机信息 1826.5  一目了然：可视化性能监控工具visual vm 1836.5.1  visual vm连接应用程序 1846.5.2  监控应用程序概况 1856.5.3  thread dump和分析 1866.5.4  性能分析 1876.5.5  内存快照分析 1896.5.6  btrace介绍 1906.6  来自jrockit的礼物：虚拟机诊断工具mission control 1986.6.1  mbean服务器 1986.6.2  飞机记录器（flight recorder） 2006.7  小结 203第7章　分析java堆 2047.1  对症才能下药：找到内存溢出的原因 2057.1.1  堆溢出 2057.1.2  直接内存溢出 2057.1.3  过多线程导致oom 2077.1.4  永久区溢出 2097.1.5  gc效率低下引起的oom 2107.2  无处不在的字符串：string在虚拟机中的实现 2107.2.1  string对象的特点 2107.2.2  有关string的内存泄漏 2127.2.3  有关string常量池的位置 2157.3  虚拟机也有内窥镜：使用mat分析java堆 2177.3.1  初识mat 2177.3.2  浅堆和深堆 2207.3.4  例解mat堆分析 2217.3.5  支配树（dominator tree） 2257.3.6  tomcat堆溢出分析 2267.4  筛选堆对象：mat对oql的支持 2307.4.1  select子句 2307.4.2  from子句 2327.4.3  where子句 2347.4.4  内置对象与方法 2347.5  更精彩的查找：visual vm对oql的支持 2397.5.1  visual vm的oql基本语法 2397.5.2  内置heap对象 2407.5.3  对象函数 2427.5.4  集合/统计函数 2477.5.5  程序化oql分析tomcat堆 2527.6  小结 255第8章　锁与并发 2568.1  安全就是锁存在的理由：锁的基本概念和实现 25
