实战ES2015-深入现代JavaScript应用开发 PDF下载 小问 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712130018
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712130018
<p>书名:实战ES2015-深入现代JavaScript应用开发</p><p>作者:小问</p><p>页数:294</p><p>定价:¥79.0</p><p>出版社:电子工业出版社</p><p>出版日期:2016-10-01</p><p>ISBN:9787121300189</p><p><h2>相关资料</h2></p>[<p>有幸作为早期预览者见证了这本书逐渐成长，看到作者以非常严谨的态度在写这本书。ES2015 对 JavaScript 来说是个质变，它在工程上有很高的价值，能够尽快学习和应用 ES2015，可以帮助技术团队解决很多问题，也许会成为一些团队开始重视工程的契机。 <br/>——程邵非(winter) 阿里巴巴高级技术专家
现代编程语言的发展，一小部分原因是程序设计语言理论本身的发展，更大一部分原因是用户（开发者）希望使用更加方便和自然的方式组织抽象代码。因为这么做能显著改善代码可读性、灵活性和可维护性，从而最终改善产品的质量。这就是我们要随着现代编程语言特性的发展而持续学习的目的所在，也是本书介绍 ES2015 是什么、如何用的意义所在。阅读本书，对现代前端开发者写更好的代码有帮助。 —— 360 奇舞团团长 月影
这本书是小问这些年来对于 JavaScript 技术的总结，同时也是一个展望。相信读者朋友阅读以后会收获满满，对自己的技术成长有更清晰的理解。在此推荐本书给各位 JavaScript、Web、Nodejs 或相关技术的开发者，以及对于相关技术感兴趣的朋友们。   <br/>—— 尼奥  LeanCloud 前端技术负责人
这本书用简洁有力的表述方式，为大家掀开了 ES2015 神秘的面纱。通过对比其他语言以及介绍语言能力扩展的背景，深入浅出地介绍了 ES2015 的每一个细节知识点。从 ES5 熟练切换到 ES6 需要一定量的实践，而本书的后两章为读者精选了两个完整的案例，建议你跟着动动手。我相信，这本书会带着你徜徉在新知识的魅力海洋中。 <br/>—— 李靖 淘宝网资深前端工程师</p>]<p><h2>本书特色</h2></p>[<p>
JavaScript在ES2015标准中的表现，以及利用ES2015中新特性在JavaScript应用开发中的实践。以清晰的思路说明ES2015的详细特性和意义，并以实际案例展示利用ES2015中的特性如何提高JavaScript应用的前端和后端的开发速度和工程化模式。
                                        </p>]<p><h2>内容简介</h2></p>[<p>√ ES2015彻底颠覆JavaScript格局，首部专著诚意满满，既倡导工程化思想，更不乏解决问题的务实。 <br/>√ 现代前端开发以产品为终极目标，追求代码可读性、灵活性和可维护性，学习ES新标意义正在于此。<br/>√ 作者多年精研技术，得到业界广泛认可，本书由贺师俊（hax）审校，程劭非（Winter）等撰文推荐。<br/>√ 语言精练，细节扎实，背景与原理描述丰富，更面向ES5→ES6人群设置完整案例，极利于动手学习。<br/> </p>]<p><h2>作者简介</h2></p>[<p>小问，本名甘超阳，高级 JavaScript 工程师，国内 Node.js 最早的研究者之一，技术布道者、讲师，参与并维护多个优秀 JavaScript 开源项目。数学系理学士，对多方面的技术领域都有研究和自己的理解，熟悉各类 JavaScript 应用的开发和机器学习应用开发。同时也是一个业余摄影师，热爱人像摄影，个人博客 http://lifemap.in 。</p>]<p><h2>目录</h2></p>
    第1章  ECMAScript版本发展历程	11.1  ECMAScript的历史更替	21.1.1  ECMA-262 / ECMA-262 Edition 2	21.1.2  ECMA-262 Edition 3	31.1.3  ECMA-262 Edition 5	41.1.4  ECMA-262 Edition 4	41.2  小结	5第2章  ES2015能为实际开发带来什么	62.1  简单概括ES2015	62.2  语法糖	72.3  工程优势	82.3.1  模块化	82.3.2  模块化与组件化结合	112.3.3  内存安全	13第1章  ECMAScript版本发展历程	11.1  ECMAScript的历史更替	21.1.1  ECMA-262 / ECMA-262 Edition 2	21.1.2  ECMA-262 Edition 3	31.1.3  ECMA-262 Edition 5	41.1.4  ECMA-262 Edition 4	41.2  小结	5第2章  ES2015能为实际开发带来什么	62.1  简单概括ES2015	62.2  语法糖	72.3  工程优势	82.3.1  模块化	82.3.2  模块化与组件化结合	112.3.3  内存安全	132.4  小结	14第3章  ES2015新语法详解	153.1  let、const和块级作用域	163.1.1  块级作用域	163.1.2  let定义变量	203.1.3  const定义常量	223.1.3.1  使用语法	233.1.3.2  const与块级作用域	253.1.4  变量的生命周期	273.1.5  更佳体验	293.1.5.1  let VS const	293.1.5.2  let、const与循环语句	303.2  箭头函数（Arrow Function）	313.2.1  使用语法	313.2.1.1  单一参数的单行箭头函数	313.2.1.2  多参数的单行箭头函数	313.2.1.3  多行箭头函数	323.2.1.4  无参数箭头函数	323.2.2  this穿透	333.2.2.1  程序逻辑注意事项	343.2.2.2  编写语法注意事项	363.3  模板字符串（Template String）	373.3.1  字符串元素注入	373.3.2  多行字符串	373.3.3  模板字符串使用语法	383.3.3.1  支持字符串元素注入	383.3.3.2  支持换行	393.3.4  注意事项	413.4  对象字面量扩展语法（Enhanced Object Literals）	413.4.1  函数类属性的省略语法	413.4.2  支持 __proto__ 注入	423.4.3  可动态计算的属性名	433.4.4  将属性名定义省略	443.5  表达式结构（Destructuring）	453.5.1  使用语法	473.5.1.1  使用对象作为返回载体（带有标签的多返回值）	473.5.1.2  使用数组作为返回载体	473.5.2  使用场景	483.5.2.1  Promise与模式匹配	483.5.2.2  Swap（变量值交换）	493.5.3  高级用法	493.5.3.1  解构别名	503.5.3.2  无法匹配的缺省值	503.5.3.3  深层匹配	503.5.3.4  配合其他新特性	523.6  函数参数表达、传参	533.6.1  默认参数值	543.6.1.1  使用语法	543.6.1.2  使用场景	543.6.2  剩余参数	553.6.2.1  使用语法	563.6.2.2  使用场景	573.6.2.3  注意事项	573.6.3  解构传参	583.7  新的数据结构	593.7.1  Set有序集合	593.7.1.1  使用语法	603.7.1.2  增减元素	613.7.1.3  检查元素	613.7.1.4  历遍元素	613.7.2  WeakSet	623.7.3  Map映射类型	643.7.3.1  使用语法	643.7.3.2  增减键值对	653.7.3.3  获取键值对	663.7.3.4  检查映射对象中的键值对	663.7.3.5  历遍映射对象中的键值对	663.7.3.6  映射对象与Object的区别	673.7.4  WeakMap	673.8  类语法（Classes）	683.8.1  使用语法	693.8.1.1  基本定义语法	693.8.1.2  继承语法	703.8.1.3  Getter/Setter	723.8.1.4  静态方法	733.8.1.5  高级技巧	773.8.2  注意事项	783.8.3  遗憾与期望	793.9  生成器（Generator）	803.9.1  由来	803.9.2  基本概念	813.9.2.1  生成器函数（Generator Function）	813.9.2.2  生成器（Generator）	823.9.3  使用方法	833.9.3.1  构建生成器函数	833.9.3.2  启动生成器	833.9.3.3  运行生成器内容	843.9.4  深入理解	853.9.4.1  运行模式	853.9.4.2  生成器函数以及生成器对象的检测	853.9.4.3  生成器嵌套	883.9.4.4  生成器与协程	903.10  Promise	933.10.1  基本语法	943.10.1.1  创建Promise对象	943.10.1.2  进行异步操作	943.10.1.3  处理Promise的状态	953.10.2  高级使用方法	973.10.2.1  Promise.all(iterable)	973.10.2.2  Promise.race(iterable)	973.11  代码模块化	983.11.1  引入模块	993.11.1.1  引入默认模块	993.11.1.2  引入模块部分接口	1003.11.1.3  引入全部局部接口到指定命名空间	1013.11.1.4  混入引入默认接口和命名接口	1013.11.1.5  不引入接口，仅运行模块代码	1023.11.2  定义模块	1023.11.3  暴露模块	1033.11.3.1  暴露单一接口	1033.11.3.2  暴露模块默认接口	1043.11.3.3  混合使用暴露接口语句	1043.11.3.4  从其他模块暴露接口	1053.11.3.5  暴露一个模块的所有接口	1053.11.3.6  暴露一个模块的部分接口	1063.11.3.7  暴露一个模块的默认接口	1063.12  Symbol	1063.12.1  基本语法	1073.12.1.1  生成唯一的Symbol值	1073.12.1.2  注册全局可重用 Symbol	1083.12.1.3  获取全局 Symbol的key	1093.12.2  常用Symbol值	1093.12.3  Symbol.iterator	1103.12.3.1  for-of循环语句与可迭代对象	1113.12.3.2  使用Symbol.iterator定义一个可迭代对象	1113.12.4  Symbol.hasInstance	1133.12.5  Symbol.match	1133.12.6  Symbol.unscopables	1143.12.7  Symbol.toPrimitive	1153.12.8  Symbol.toStringTag	1163.13  Proxy	1173.13.1  元编程	1173.13.2  使用语法	1183.13.3  handler.has	1193.13.4  handler.get	1203.13.5  handler.set	1213.13.6  handler.apply	1223.13.7  handler.construct	1223.13.8  创建可解除Proxy对象	1233.13.9  使用场景	1233.13.9.1  看似“不可能”的自动填充	1233.13.9.2  只读视图	1243.13.9.3  入侵式测试框架	1253.14  小结	127第4章  ES2015的前端开发实战	1294.1  Filmy的功能规划	1294.1.1  数据分级	1304.1.2  数据结构	1304.1.2.1  核心数据	1304.1.2.2  分类数据	1314.1.2.3  相册数据	1314.1.3  数据搜索	1324.1.3.1  搜索分类	1324.1.3.2  搜索相册	1324.1.4  界面原型规划	1334.1.4.1  着陆页面	1334.1.4.2  分类目录页面	1334.1.4.3  分类内容页面	1344.1.4.4  相册页面	1344.2  功能组件分割	1354.2.1  根组件分割	1354.2.2  着陆页面	1364.2.3  目录页面	1364.2.4  分类页面	1374.2.5  相册页面	1374.3  技术选型	1394.3.1  整体架构	1394.3.2  数据层	1394.3.3  逻辑层及UI层	1404.3.3.1  AngularJS	1414.3.3.2  React.js	1414.3.3.3  Vue.js	1424.3.4  程序架构	1434.3.4.1  路由组件	1434.3.4.2  数据组件	1444.3.4.3  视图组件	1454.4  数据层开发	1464.4.1  安装依赖	1474.4.2  配置七牛JavaScript SDK	1474.4.3  核心配置数据	1504.4.3.1  获取核心配置数据	1504.4.3.2  更新配置数据	1514.4.4  分类数据	1544.4.4.1  数据结构	1554.4.4.2  数据索引	1574.4.4.3  更新分类数据	1594.4.5  相册数据	1594.4.5.1  数据加载	1604.4.5.2  数据更新	1614.4.5.3  数据检索	1614.5  入口文件与路由组件开发	1654.5.1  路由基础组件	1664.5.2  入口文件	1664.5.2.1  简单的字符串处理	1674.5.2.2  多国语言处理	1684.6  着陆页面开发	1704.6.1  路由组件开发	1714.6.2  着陆页视图	1744.6.2.1  引入数据	1744.6.2.2  绑定视图	1744.6.3  分类目录视图	1774.6.3.1  分类元素视图组件	1774.6.3.2  渲染分类目录	1784.6.4  路由组件、视图组件与数据组件的联系	1804.6.4.1  在逻辑控制器中进行数据操作	1804.6.4.2  在视图中进行数据操作	1814.6.4.3  组织方式的区别与项目应用	1824.7  分类页面开发	1824.7.1  路由组件开发	1834.7.2  分类元素视图组件	1854.7.3  相册列表视图组件	1864.7.4  相册页面开发	1884.7.4.1  相册页面的路由组件	1884.7.4.2  相册信息视图组件	1894.7.4.3  图片列表视图组件	1894.8  管理工具开发	1904.9  初始化Filmy实例	1914.9.1  基本元素	1924.9.2  基本逻辑	1944.9.2.1  获取七牛云的上传凭证	1954.9.2.2  检查并处理管理员对背景图片的填写方式	1964.9.2.3  将核心数据部署到七牛云上	1974.10  管理工具的总体组织	1974.10.1  管理页面的总体架构	1984.10.2  侧边栏	1984.10.3  路由配置	2004.11  相册发布页面	2024.11.1  基本逻辑	2024.11.1.1  绑定数据	2024.11.1.2  绑定元素以接收文件上传	2034.11.2  上传数据	2044.11.2.1  图片上传逻辑	2044.11.2.2  数据提交	2054.12  打包发布	2064.12.1  准备工作	2064.12.2  配置 webpack	2074.12.2.1  安装依赖	2074.12.2.2  编写配置文件	2074.12.3  发布到云端	2094.13  小结	210第5章  ES2015的Node.js开发实战	2115.1  Duel Living的功能规划	2115.1.1  基本产品组织	2115.1.2  数据结构	2135.1.2.1  赛事（Duel）	2135.1.2.2  消息（Message）	2145.1.2.3  参赛方（Player）和主持人（Host）	2165.1.3  数据结构的关系	2165.2  数据层开发	2175.2.1  文件结构	2175.2.2  安装依赖	2175.2.3  主持人数据和参赛方数据	2185.2.4  赛事数据	2235.2.5  消息数据	2255.3  服务端基本架构开发	2275.3.1  安装依赖	2275.3.2  程序入口	2295.3.3  路由表	2295.4  API开发	2305.4.1  API安全	2305.4.2  赛事API	2315.4.2.1  获取当前可用的所有赛事信息	2325.4.2.2  获取指定赛事数据	2325.4.2.3  创建新的赛信息
