实战Gradle PDF下载 马斯可 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712126925
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712126925
<p>书名:实战Gradle</p><p>作者:马斯可</p><p>页数:463</p><p>定价:¥89.0</p><p>出版社:电子工业出版社</p><p>出版日期:2015-09-01</p><p>ISBN:9787121269257</p><p><h2>相关资料</h2></p>[<p>“一本权威指南。” <br/>
— 摘自hans dockter之序，gradle和gradleware的创建者<br/>
<br/>
“自动化构建的新方式，你永远不会怀念旧的。”<br/>
— nacho ormeno, startupxplore<br/>
<br/>
“多语言程序员必读！”<br/>
— rob bugh, reachforce<br/>
<br/>
“**的gradle参考！充满了真实案例。”<br/>
— wellington r.pinheiro 巴西沃尔玛电商<br/>
<br/>
“帮助所有开发者使用gradle所缺少的一本书。”<br/>
— samuel brown, blackboard, inc.</p>]<p><h2>本书特色</h2></p>[<p>
gradle 是java 软件开发中的自动化构建工具，类似于传统工具如ant 和maven。gradle 吸收或用了maven 中比较成功的一些实践，但相对于maven 或ant 又有极强的扩展。
《实战gradle》（gradle in action）全方位地讲解了gradle 工具相关的知识，包括gradle 的基本识、自动化构建的基本概念和**实践，以实际案例的方式解释如何使用gradle 进行软件项目构建。
除了基础知识外，由于软件开发**不仅仅是实现业务逻辑代码，书中还介绍了一些解决软件开中常见问题的实践，如多语言、多项目构建，gradle 在持续集成和持续交付中的应用，gradle 构建jvm 其他语言，以及gradle 集成javascript 构建等。
云计算和devops 的兴起，给软件行业带来了翻天覆地的变化，书中对于云计算平台、开源社区的一些工具与gradle 的结合使用也做了相关的介绍。
因为groovy 用于编写gradle 构建配置的dsl，所以为了帮助读者更好地理解gradle，本书还讲了groovy 的基本知识，虽然不是全方位地讲解groovy，但是理解gradle 足矣。
                                        </p>]<p><h2>内容简介</h2></p>[<p>gradle是一个通用的自动化构建工具。其继承了先驱者ant和maven所建立的使用模式，并且允许构建具有表达性、可维护性和容易理解。使用灵活的基于groovy的dsl，gradle提供了声明式的可扩展语言元素，让你能够随心所欲地建模项目需求。《实战gradle》是关于使用gradle实现端到端的项目自动化的综合指南。从基础知识开始介绍，具有实践性，易于阅读，讨论了在实际项目中如何建立高效的完整的构建过程。在这个过程中，涵盖了一些高级话题，如测试、持续集成和代码质量监测。你还会体验到像设置目标环境和部署软件这样的具体任务。本书内容包括：
关于gradle的综合指南；
真实的实践案例；
从ant和maven过渡；
深入讲解插件开发；
使用gradle实现持续交付。
本书假设读者具有java基础背景，但是不要求具备groovy知识。
benjamin muschko是gradleware工程师团队的成员，同时也是很多流行的gradle插件的作者。
如需下载免费的pdf、epub和kindle形式的电子书，本书的拥有者可以访问manning.com/gradleinaction。</p>]<p><h2>作者简介</h2></p>[<p>Benjamin Muschko 是一名拥有超过 10 年开发和交付商业软件工作经验的软件开发工程师。他是 Gradleware 工程团队的成员，也是多个 Gradle 流行插件的作者。</p>]<p><h2>目录</h2></p>
    第1 部分 gradle 介绍  11　项目自动化介绍  31.1 没有项目自动化的生活  41.2 项目自动化的好处  51.2.1 防止手动介入  51.2.2 创建可重复的构建  51.2.3 让构建便携  51.3 项目自动化的类型  61.3.1 按需构建  61.3.2 触发构建  71.3.3 预定构建  71.4 构建工具  81.4.1 什么是构建工具  91.4.2 构建工具的剖析  101.5 java 构建工具  121.5.1 apache ant  121.5.2 apache maven  161.5.3 对下一代构建工具的需求  191.6 总结  202　下一代构建工具：gradle 232.1 为什么要用gradle，为什么是现在  242.1.1 java 构建工具的演变  252.1.2 为什么应该选择gradle  272.2 gradle 引人注目的特性集  292.2.1 可表达性的构建语言和底层的api  292.2.2 gradle 就是groovy  312.2.3 灵活的约定  322.2.4 鲁棒和强大的依赖管理  332.2.5 可扩展的构建  342.2.6 轻松的可扩展性  342.2.7 和其他构建工具集成  352.2.8 社区和公司的推动  362.2.9 锦上添花：额外的特性  362.3 更大的场景：持续交付  362.3.1 从构建到部署自动化项目  372.4 安装gradle  382.5 开始使用gradle  402.6 使用gradle 的命令行  422.6.1 列出项目中所有可用的task  432.6.2 任务执行  442.6.3 命令行选项  462.6.4 gradle 守护进程  472.7 总结  483　通过范例学习构建gradle 项目 493.1 介绍学习案例  503.1.1 to do 应用程序  503.1.2 任务管理用例  503.1.3 检查组件交互  513.1.4 构建应用功能  523.2 构建java 项目  553.2.1 使用java 插件  553.2.2 定制你的项目  593.2.3 配置和使用外部依赖  603.3 用gradle 做web 开发  623.3.1 添加web 组件  623.3.2 使用war 和jetty 插件  643.4 gradle 包装器  693.4.1 配置包装器  703.4.2 使用包装器  713.4.3 定制包装器  733.5 总结  73第2 部分 掌握基本原理 754　构建脚本概要 774.1 构建块  784.1.1 项目  784.1.2 任务  804.1.3 属性  804.2 使用task  824.2.1 项目版本管理  824.2.2 声明task 动作  834.2.3 访问defaulttask 属性  844.2.4 定义task 依赖  854.2.5 终结器task  864.2.6 添加任意代码  874.2.7 理解task 配置  874.2.8 声明task 的inputs 和outputs  904.2.9 编写和使用自定义task  924.2.10 gradle 的内置task 类型  954.2.11 task 规则  974.2.12 在buildsrc 目录下构建代码  1004.3 挂接到构建生命周期  1014.3.1 挂接到task 执行图  1034.3.2 实现task 执行图监听器 1034.3.3 初始化构建环境  4.4 总结  1065　依赖管理 1075.1 依赖管理概述  1085.1.1 不完善的依赖管理技术  1085.1.2 自动化依赖管理的重要性  1085.1.3 使用自动化依赖管理  1105.1.4 自动化依赖管理的挑战  1105.2 通过例子学习依赖管理  1125.3 依赖配置  1135.3.1 理解配置api 表示  1135.3.2 自定义配置  1145.3.3 访问配置  1155.4 声明依赖  1155.4.1 理解依赖api 表示  1165.4.2 外部模块依赖  1175.4.3 文件依赖  1215.5 使用和配置仓库  1225.5.1 理解仓库api 表示  1235.5.2 maven 仓库  1245.5.3 ivy 仓库  1265.5.4 扁平的目录仓库  1265.6 理解本地依赖缓存  1275.6.1 分析缓存结构  1275.6.2 显著的缓存特性  1295.7 解决依赖问题  1305.7.1 应对版本冲突  1305.7.2 强制指定一个版本  1315.7.3 使用依赖观察报告  1315.7.4 刷新缓存  1325.8 总结  1336　多项目构建 1356.1 模块化项目  1366.1.1 耦合与内聚  1366.1.2 模块划分  1376.1.3 模块化重构  1386.2 组装多项目构建  1396.2.1 settings 文件介绍  1406.2.2 理解settings api 表示  1416.2.3 settings 执行  1426.2.4 获取settings 文件  1426.2.5 分层布局与扁平布局  1436.3 配置子项目  1446.3.1 理解project api 表示  1456.3.2 定义特定的行为  1466.3.3 声明项目依赖  1476.3.4 多项目部分构建  1496.3.5 声明跨项目的task 依赖  1516.3.6 定义公共行为  1536.4 独立的项目文件  1546.4.1 为每个项目创建构建文件  1556.4.2 定义根项目的构建代码  1556.4.3 定义子项目的构建代码  1556.5 自定义项目  1566.6 总结  1577　gradle 测试 1597.1 自动化测试  1607.1.1 自动化测试类型  1607.1.2 自动化测试金字塔  1607.2 测试java 应用程序  1617.2.1 项目布局  1627.2.2 测试配置  1627.2.3 测试task  1637.2.4 自动化测试检测  1647.3 单元测试  1647.3.1 使用junit  1647.3.2 使用其他的单元测试框架  1687.3.3 结合使用多个单元测试框架  1707.4 配置测试执行  1727.4.1 命令行选项  1737.4.2 理解测试api 表示  1747.4.3 控制运行时行为  1757.4.4 控制测试日志  1767.4.5 并行执行测试  1787.4.6 响应测试生命周期事件  1797.4.7 实现测试监听器  1807.5 集成测试  1817.5.1 引入用例研究  1817.5.2 编写测试类  1817.5.3 在构建中支持集成测试  1827.5.4 为集成测试建立约定  1847.5.5 引导测试环境  1867.6 功能测试  1877.6.1 引入用例研究  1877.6.2 在构建中支持功能测试  1887.7 总结  1928　扩展gradle 1958.1 通过案例学习介绍插件  1968.1.1 在云中使用grade 管理应用  1968.1.2 设置云环境  1978.2 从零起步构建插件  2008.3 写一个脚本插件  2018.3.1 添加cloudbees 的api 类库  2018.3.2 在task 中使用cloudbees 的api  2028.4 编写定制的task 类  2068.4.1 定制task 的实现选项  2068.4.2 在buildsrc 下定义定制任务  2078.5 使用和构建对象插件  2148.5.1 使用对象插件  2158.5.2 解析对象插件  2178.5.3 编写对象插件  2188.5.4 插件扩展机制  2198.5.5 给插件一个有意义的名字  2228.5.6 测试对象插件  2228.5.7 开发和使用独立的对象插件  2248.6 总结  2269　集成与迁移 2299.1 ant 与gradle  2309.1.1 在gradle 中使用ant 脚本功能  2319.1.2 在gradle 中使用标准的ant 任务  2379.1.3 迁移策略  2399.2 maven 和gradle  2429.2.1 异同之处  2439.2.2 迁移策略  2469.3 比较构建  2499.4 总结  251第3 部分 从构建到部署 25310　ide 支持和工具 25510.1 使用ide 插件生成项目文件  25610.1.1 使用eclipse 插件  25710.1.2 使用idea 插件  26510.1.3 使用sublime text 插件  27010.2 在流行的ide 中管理gradle 项目  27310.2.1 springsource sts 对gradle 的支持  27410.2.2 intellij idea 对gradle 的支持  27810.2.3 netbeans 对gradle 的支持  28010.3 使用工具api 集成gradle  28310.4 总结
