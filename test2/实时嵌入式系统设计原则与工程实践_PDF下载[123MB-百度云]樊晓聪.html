实时嵌入式系统设计原则与工程实践 PDF下载 樊晓聪 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730245559
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730245559
<p>书名:实时嵌入式系统设计原则与工程实践</p><p>作者:樊晓聪</p><p>页数:530</p><p>定价:¥79.8</p><p>出版社:清华大学出版社</p><p>出版日期:2017-01-01</p><p>ISBN:9787302455592</p><p><h2>本书特色</h2></p>[<p>
本书融入了实时系统、嵌入式系统和软件工程的新概念和新主题，为开发实时嵌入式应用软件描绘了一幅完整的图像。在本书中，你不仅可以全面地理解与微处理器、中断和系统引导过程相关的概念，领略到实时建模和调度的重要性，而且也将学习建模文档、建模分析、设计模式和标准的一致性等软件工程实践。本书分为四个部分，帮助你学习嵌入式系统的关键概念；第Ⅰ部分介绍了开发过程，包括微处理器和中断章节——这是软件工程师的基本主题；第Ⅱ部分专门介绍了实时系统的建模技术；第Ⅲ部分讨论了软件体系架构的设计；第Ⅳ部分检验了软件的实现，并重点关注POSIX兼容的操作系统。
主要特色
◆ 涵盖了*的UML标准(UML 2.4)
◆ 超过20种具有代表性，可以在一个非常广泛的实时嵌入式系统系列中重用的*的设计模式实践
◆ 在QNX中通过测试的示例代码，QNX是在行业中广泛采用的实时操作系统。
主要内容
◆ 不同嵌入式系统架构的利弊
◆ POSIX实时扩展以及如何开发POSIX兼容的实时应用程序
◆ 如何使用实时UML记录具有时序约束的系统设计
◆ 与跨平台开发相关的概念以及所面临的挑战
◆ 多任务设计和任务间通信技术(共享内存对象、消息队列、管道、信号)
◆ 如何使用内核对象(如信号量、互斥体、条件变量)来解决RTOS应用程序资源共享的问题
◆ 支持“资源管理器”这个概念的原理，以及如何使用资源管理器实现虚拟文件系统
◆ 实时调度和几个关键算法的基本原则
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书介绍开发实时嵌入式软件至关重要的三个方面。首先，开发实时嵌入式系统软件涉及许多活动，包括需求规格说明、时序分析、体系架构设计、多任务设计以及跨平台的测试和调试。本书涵盖嵌入式软件开发的全过程，对一些主题进行全面充分的解释，而对另外一些主题则一笔带过(例如，调试和测试)。 </p>]<p><h2>作者简介</h2></p>[<p>      Xiaocong Fan是宾夕法尼亚州立大学计算机和软件工程学院的副教授。他的研究领域包括软件工程中的多智能体系统和形式化方法，以及先进的决策支持系统。他是一些智能代理系统(如RCAST和SMMall)的主要设计师。Fan博士是IEEE的高级会员。</p>]<p><h2>目录</h2></p>
    第Ⅰ部分  引    言
第1章  嵌入式系统和实时系统导论
1
1.1  嵌入式系统 3
1.2  实时系统 4
1.2.1 
软实时系统 4
1.2.2 
硬实时系统 5
1.2.3 
实时系统的范围 6
1.3  案例分析：雷达系统 7
1.4  习题 10
第2章  跨平台开发 11
2.1　跨平台开发流程 11
2.2  硬件架构 12
2.3　软件开发 13
2.3.1　软件设计 13
2.3.2　系统编程语言C/C   13
2.3.3 
测试硬件无关模块 18
2.4  生成目标映像 18
2.4.1 
交叉开发工具链 18
2.4.2 
可执行和链接格式 21
2.4.3 
内存映射 26
2.4.4 
案例研究：制作QNX映像 28
2.5  转移可执行文件对象到
目标平台 29
2.6  在目标系统上的集成测试
30
2.7  系统生产 30
2.8  习题 31
第3章  微处理器入门 33
3.1  微处理器简介 33
3.1.1 
常用的微处理器 33
3.1.2 
微处理器特性 35
3.2 
PIC18F8720微型芯片 38
3.2.1 
存储器组织 39
3.2.2 
字写模式 41
3.2.3 
字节选择模式 43
3.2.4 
字节写模式 45
3.3 
Intel 8086 46
3.3.1 
存储器组织 47
3.3.2 
独立的I/O地址空间 48
3.3.3 
存储器地址空间 50
3.3.4 
等待状态 52
3.4 
Intel Pentium 53
3.4.1 
总线状态转换 56
3.4.2 
存储器组织 60
3.5 
ARM926EJ-S 61
3.6  习题 64
第4章  中断 67
4.1  中断导论 67
4.2  外部中断 67
4.2.1 
非向量中断 68
4.2.2 
PIC和向量中断 69
4.3  软件中断 74
4.4  内部中断 75
4.5 
ISR的设计模式 75
4.5.1 
一般的ISR设计模式 75
4.5.2 
具有服务器任务的ISR 76
4.5.3 
ISR链 77
4.5.4 
ISR级联 78
4.5.5 
与ISR进行数据共享 79
4.6  中断响应时间 81
4.7  案例分析：x86 82
4.7.1 
硬件中断 84
4.7.2 
综合汇总 85
4.8  案例研究：ARM处理器 86
4.8.1 
硬件中断 87
4.8.2 
综合汇总 90
4.9  习题 91
第5章  嵌入式系统的引导过程 93
5.1  系统引导加载程序 93
5.2  系统的引导过程 94
5.2.1 
加载嵌入式软件 94
5.2.2 
准备执行嵌入式软件 95
5.3  案例研究：AT91SAM9G45
引导过程 96
5.4  加载嵌入在操作系统映像中的
ELF目标文件 96
5.5  案例研究：基于QNX嵌入式
系统的引导过程 97
5.6 习题 99
第Ⅱ部分  实时系统建模
第6章  UML结构建模基础 103
6.1  统一建模语言 103
6.2  类图和类建模 104
6.2.1 
类 106
6.2.2 
实例层次的关系 109
6.2.3 
依赖关系 121
6.2.4 
泛化关系 125
6.3  类建模原则 128
6.3.1 
模型演化 128
6.3.2 
子类化 130
6.3.3 
*小信息冗余 131
6.3.4 
重构 134
6.4  对象图 137
6.5  包图 138
6.5.1 
包引入 138
6.5.2 
包合并 139
6.6  习题 141
第7章  UML体系架构建模 143
7.1  体系架构的抽象层次 143
7.2 
UML结构图 144
7.3  建模组件 148
7.4  子系统建模 150
7.5  完整系统建模 153
7.6  部署图 154
7.7  习题 155
第8章  UML行为建模的基础 157
8.1  用例图和用例建模 157
8.1.1 
用例图 157
8.1.2 
用例描述 160
8.1.3 
用例层次 161
8.2  序列图 162
8.3  活动图 167
8.4  习题 171
第9章  UML中有状态行为的建模 173
9.1  状态机图的基础 173
9.1.1 
状态 173
9.1.2 
转移和事件 174
9.1.3 
伪状态 175
9.1.4 
用状态机对网络协议建模 176
9.2  复合状态 178
9.2.1 
进入点、退出点与历史 179
9.2.2 
并发 180
9.3  状态行为的继承 181
9.4  有状态对象时序图 183
9.5  举例：雷达系统有状态行为
的建模 184
9.5.1 
收发机建模 185
9.5.2 
链路驱动器的建模 186
9.5.3 
指挥消息器的建模 188
9.6  习题 189
第10章  实时UML：通用资源
建模 191
10.1 
实时UML配置文件 191
10.2 
资源建模 194
10.2.1 
UML核心资源模型 195
10.2.2 
动作和动作执行 196
10.2.3 
受保护资源的UML构
造型 197
10.2.4 
资源使用 199
10.2.5 
资源-客户图 200
10.3 
时间建模 201
10.3.1 
时间观念 201
10.3.2 
定时装置 202
10.3.3 
时间建模构造型 204
10.4 
并发建模 206
10.5 
习题 209
第11章  实时UML：模型分析 211
11.1 
时序约束的启发 211
11.2 
RT-UML配置文件可调度性
建模子配置文件 214
11.2.1 
RT-UML配置文件中的可
调度性分析的元概念 214
11.2.2 
可调度性构造型 219
11.2.3 
使用可调度性子配置
文件 221
11.3 
RT-UML配置文件性能建模
子配置文件 223
11.3.1 
RT-UML配置文件中的性
能分析的元概念 223
11.3.2 
性能构造型 225
11.3.3 
使用性能子配置文件 227
11.4 
习题 231
第Ⅲ部分  实时系统设计
第12章  实时嵌入式系统软件
架构 237
12.1 
实时任务 237
12.1.1 
*坏情况下的任务执行
时间 238
12.1.2 
任务规范 239
12.1.3 
任务时序图 239
12.1.4 
*坏情况下的响应时间 241
12.1.5 
任务实现 242
12.2 
轮询架构 242
12.2.1 
案例研究：体温计 242
12.2.2 
通用轮询架构 250
12.2.3 
*坏情况下的事件响应
时间 253
12.3 
带有中断的轮询 254
12.3.1 
案例研究：西蒙游戏 254
12.3.2 
通用架构 257
12.3.3 
*坏情况下的事件响应
时间 259
12.4 
基于队列的架构 260
12.4.1 
非抢占式FIFO队列 261
12.4.2 
非抢占式优先队列 262
12.5 
习题 264
第13章  POSIX和RTOS 267
13.1 
POSIX简介 267
13.1.1 
POSIX进程和线程 268
13.1.2 
POSIX实时扩展 269
13.1.3 
POSIX的兼容性和一
致性 275
13.2 
任务的静态结构和动态
行为 276
13.2.1 
一般任务结构 276
13.2.2 
任务状态转移 278
13.3 
实时操作系统 279
13.4 
POSIX实时调度策略 282
13.4.1 
FIFO调度策略 282
13.4.2 
轮询调度策略 283
13.4.3 
偶发服务器调度策略 284
13.5 
其他实时调度策略 286
13.5.1 
*小松弛度优先 286
13.5.2 
*早截止期限优先 287
13.5.3 
截止期限单调分配的
调度 288
13.5.4 
速率单调分配的调度 288
13.6 
习题 289
第14章  多任务 291
14.1 
多任务简介 291
14.2 
多任务设计 292
14.2.1 
任务标识 292
14.2.2 
任务转换 295
14.2.3 
任务参数估计 299
14.3 
多任务资源共享 301
14.3.1 
资源死锁 301
14.3.2 
优先级反转 302
14.4 
解决资源死锁 304
14.4.1 
死锁预防 304
14.4.2 
死锁检测 304
14.4.3 
死锁避免 305
14.5 
解决优先级反转 307
14.5.1 
优先级继承协议 307
14.5.2 
*高锁协议 309
14.5.3 
优先级天花板协议 310
14.6 
习题 312
第15章  实时调度：时钟驱动
方式 315
15.1 
周期性调度简介 315
15.1.1 
若干假设 315
15.1.2 
可抢占的非周期作业 316
15.2 
点对点时钟驱动调度 317
15.2.1 
点对点时钟驱动调度
程序 318
15.2.2 
执行开销 319
15.3 
基于帧的调度 320
15.3.1 
帧尺寸的约束 320
15.3.2 
健壮的基于帧的调度 323
15.3.3 
基于帧的调度程序 324
15.4 
调度非周期作业 325
15.5 
拆分任务 328
15.6 
习题 330
第16章  实时调度：速率单调
方式 331
16.1 
优先级分配 331
16.2 
RMA原则 332
16.3 
速率单调分析 335
16.4 
完成时间测试 336
16.5 
周期变换 339
16.6 
通用的可调度性分析 342
16.6.1 
具有阻塞时间项的任务 342
16.6.2 
具有更早截止时间的
任务 346
16.6.3 
示例 347
16.6.4 
优先级相同的任务 350
16.7 
习题 351
第17章  实时调度：偶发服务器
程序 355
17.1 
偶发任务
355
17.2 
偶发服务器程序 356
17.2.1 
偶发服务器程序的相关
任务设计 356
17.2.2 
验收测试 358
17.3 
朴素偶发服务器程序 360
17.3.1 
任务设计 361
17.3.2 
验收测试 361
17.4 
固定优先级的偶发服务器
程序 362
17.5 
具有动态优先级的偶发
服务器程序 368
17.6 
习题 371
第IV部分  实现模式
第18章  资源共享 375
18.1 
共享变量 375
18.2 
共享的内存 378
18.2.1 
映射文件对象 380
18.2.2 
共享的内存对象 382
18.3 
信号量 384
18.3.1 
任务同步 385
18.3.2 
流控制 387
18.3.3 
资源保护 387
18.3.4 
信号量相关的POSIX
函数 389
18.3.5 
信号量示例 390
18.4 
互斥体 397
18.4.1 
互斥体使用模式 398
18.4.2 
互斥体相关的POSIX
函数 400
18.4.3 
使用互斥体的例子 401
18.5 
条件变量 404
18.5.1 
栅栏同步 405
18.5.2 
生产者-消费者模式 410
18.5.3 
读-写锁 414
18.6 
习题 418
第19章  任务间通信：消息队列
421
19.1 
消息队列简介 421
19.2 
消息队列静态结构和动态
转移 421
19.3 
消息队列使用模式 424
19.3.1 
单向通信 424
19.3.2 
确认-单向通信 425
19.3.3 
双向通信 426
19.3.4 
客户端-服务器之间的
通信 427
19.4 
与消息队列相关的POSIX
函数 430
19.5 
使用消息队列的例子 432
19.6 
习题 437
第20章  任务间通信：管道 439
20.1 
管道简介 439
20.2 
管道的静态结构和动态
状态转移 439
20.3 
管道使用模式 442
20.4 
与管道相关的POSIX函数 442
20.4.1 
多个作者和读者 444
20.4.2 
在管道上POSIX的选择
操作 445
20.5 
使用管道的示例 446
20.6 
习题 451
第21章  任务间通信：发送信号
453
21.1 
POSIX信号简介 453
21.2 
信号处理 455
21.3 
信号向量表和处理程序 455
21.4 
POSIX信号函数 456
21.5 
POSIX信号的QNX实现 457
21.5.1 
示例：在不同进程中处理
信号 457
21.5.2 
示例：控制任务服务器 460
21.6 
来自ISR的自旋锁和中断
事件 463
21.6.1 
POSIX自旋锁 463
21.6.2 
QNX事件结构 464
21.6.3 
QNX应用程序的中断
处理 465
21.6.4 
示例：来自ISR的中断
事件 466
21.7 
QNX脉冲 473
21.7.1 
QNX同步消息传递 473
21.7.2 
QNX异步脉冲发生机制 476
21.7.3 
分层消息传递模式 478
21.7.4 
消息接收者的优先级
继承 478
21.7.5 
示例：简单的计时管
理器 479
21.8 
习题 488
第22章  软件计时器管理 489
22.1 
硬件计时器和软件计时器 489
22.2 
软件计时管理器 491
22.2.1 
链接到专用计时器ISR 492
22.2.2 
使用OS计时器 492
22.3 
计时轮 493
22.3.1 
精度误差 495
22.3.2 
宽范围计时器 497
22.4 
分层计时轮 497
22.4.1 
计时轮参考上下文和计时
器管理 498
22.4.2 
实现 500
22.5 
习题 502
第23章  QNX资源管理 505
23.1 
QNX资源管理简介 505
23.2 
资源管理器体系架构 506
23.2.1 
控制结构 507
23.2.2 
关键数据结构 508
23.3 
示例1：作为资源管理器的
计算器 508
23.3.1 
上层结构 509
23.3.2 
处理来自客户端的消息 510
23.3.3 
注册到进程管理器 517
23.3.4 
使用资源管理器 518
23.4 
示例2：设备驱动程序 520
23.4.1 
操纵杆 520
23.4.2 
LED指示灯 521
23.4.3 
基于轮询的输入事件
检测 523
23.5 
习题 526
参考文献 527
缩略语 531
 
