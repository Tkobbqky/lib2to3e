微服务设计 PDF下载 纽曼 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711542026
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711542026
<p>书名:微服务设计</p><p>作者:纽曼</p><p>页数:209</p><p>定价:¥69.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2016-04-01</p><p>ISBN:9787115420268</p><p><h2>相关资料</h2></p>[<p>“微服务架构有很多吸引人的地方，但一不留神，就会在微服务之路上遭遇很多令人痛苦的陷阱。这本书会帮助你确定微服务这条路是否适合你，以及如何在你的旅程中避免这些陷阱。”——martin fowler，软件开发大师，thoughtworks首席科学家</p>]<p><h2>本书特色</h2></p>[<p>
本书全面介绍了微服务的建模、集成、测试、部署和监控，通过一个虚构的公司讲解了如何建立微服务架构。主要内容包括认识微服务在保证系统设计与组织目标统一上的重要性，学会把服务集成到已有系统中，采用递增手段拆分单块大型应用，通过持续集成部署微服务，等等。
                                        </p>]<p><h2>内容简介</h2></p>[<p>　　过去十年中，分布式系统的粒度变得越来越细，包含大量代码的单块应用逐渐转变为自包含的微服务。但开发微服务系统也有一些让人头疼的问题。本书通过大量的例子，全面讨论了系统架构师和管理员在构建、管理和演化微服务架构时必须考虑的问题，并给出了实用的建议。
　　本书不但详细地阐述了微服务的基本概念，而且还深入探究了如何对自治服务进行建模、集成、测试、部署及监控。书中虚构了某个领域的一家公司，来帮助读者学习微服务架构是如何影响一个领域的。
　　了解微服务如何将系统设计与组织目标相匹配　　
　　掌握将一个服务和现有系统进行集成的不同方式
　　使用增量式的做法拆分单块代码库
　　通过持续集成部署各个微服务
　　审视对分布式系统进行测试和监控的复杂性
　　管理“用户-服务”和“服务-服务”两种模式下的安全性
　　理解微服务架构在规模化方面所面临的问题 </p>]<p><h2>作者简介</h2></p>[<p>Sam Newman是ThoughtWorks公司的技术专家、ThoughtWorks内部系统架构师，同时还为全球的客户提供咨询服务。他在开发和IT运维方面与全球多个领域的公司有过合作。</p>]<p><h2>目录</h2></p>
    前言 xiv第1　章 微服务　11．1　什么是微服务　21．1．1　很小，专注于做好一件事　21．1．2　自治性　31．2　主要好处　31．2．1　技术异构性　31．2．2　弹性　41．2．3　扩展　51．2．4　简化部署　51．2．5　与组织结构相匹配　61．2．6　可组合性　61．2．7　对可替代性的优化　61．3　面向服务的架构　71．4　其他分解技术　71．4．1　共享库　81．4．2　模块　81．5　没有银弹　91．6　小结　10第2　章 演化式架构师　112．1　不准确的比较　112．2　架构师的演化视角　122．3　分区　142．4　一个原则性的方法　152．4．1　战略目标　152．4．2　原则　152．4．3　实践　162．4．4　将原则和实践相结合　162．4．5　真实世界的例子　162．5　要求的标准　172．5．1　监控　182．5．2　接口　182．5．3　架构安全性　182．6　代码治理　182．6．1　范例　192．6．2　裁剪服务代码模板　192．7　技术债务　202．8　例外管理　212．9　集中治理和领导　212．10　建设团队　222．11　小结　23第3　章 如何建模服务　243．1　musiccorp 简介　243．2　什么样的服务是好服务　253．2．1　松耦合　253．2．2　高内聚　253．3　限界上下文　263．3．1　共享的隐藏模型　263．3．2　模块和服务　273．3．3　过早划分　283．4　业务功能　283．5　逐步划分上下文　293．6　关于业务概念的沟通　303．7　技术边界　303．8　小结　31第4　章 集成　324．1　寻找理想的集成技术　324．1．1　避免破坏性修改　324．1．2　保证api 的技术无关性　324．1．3　使你的服务易于消费方使用　334．1．4　隐藏内部实现细节　334．2　为用户创建接口　334．3　共享数据库　334．4　同步与异步　354．5　编排与协同　354．6　远程过程调用　384．6．1　技术的耦合　384．6．2　本地调用和远程调用并不相同　394．6．3　脆弱性　394．6．4　rpc 很糟糕吗　404．7　rest　414．7．1　rest 和http　414．7．2　超媒体作为程序状态的引擎　424．7．3　json、xml 还是其他　444．7．4　留心过多的约定　444．7．5　基于http 的rest 的缺点　454．8　实现基于事件的异步协作方式　464．8．1　技术选择　464．8．2　异步架构的复杂性　474．9　服务即状态机　484．10　响应式扩展　484．11　微服务世界中的dry 和代码重用的危险　494．12　按引用访问　504．13　版本管理　514．13．1　尽可能推迟　514．13．2　及早发现破坏性修改　524．13．3　使用语义化的版本管理　534．13．4　不同的接口共存　534．13．5　同时使用多个版本的服务　544．14　用户界面　554．14．1　走向数字化　564．14．2　约束　564．14．3　api 组合　574．14．4　ui 片段的组合　574．14．5　为前端服务的后端　594．14．6　一种混合方式　604．15　与第三方软件集成　614．15．1　缺乏控制　614．15．2　定制化　624．15．3　意大利面式的集成　624．15．4　在自己可控的平台进行定制化　624．15．5　绞杀者模式　644．16　小结　65第5　章 分解单块系统　665．1　关键是接缝　665．2　分解musiccorp　675．3　分解单块系统的原因　685．3．1　改变的速度　685．3．2　团队结构　685．3．3　安全　685．3．4　技术　685．4　杂乱的依赖　695．5　数据库　695．6　找到问题的关键　695．7　例子：打破外键关系　705．8　例子：共享静态数据　715．9　例子：共享数据　725．10　例子：共享表　735．11　重构数据库　745．12　事务边界　755．12．1　再试一次　765．12．2　终止整个操作　775．12．3　分布式事务　775．12．4　应该怎么办呢　785．13　报告　785．14　报告数据库　785．15　通过服务调用来获取数据　805．16　数据导出　815．17　事件数据导出　825．18　数据导出的备份　835．19　走向实时　845．20　修改的代价　845．21　理解根本原因　845．22　小结　85第6　章 部署　866．1　持续集成简介　866．2　把持续集成映射到微服务　876．3　构建流水线和持续交付　906．4　平台特定的构建物　916．5　操作系统构建物　926．6　定制化镜像　936．6．1　将镜像作为构建物　946．6．2　不可变服务器　956．7　环境　956．8　服务配置　966．9　服务与主机之间的映射　976．9．1　单主机多服务　976．9．2　应用程序容器　996．9．3　每个主机一个服务　1006．9．4　平台即服务　1016．10　自动化　1016．11　从物理机到虚拟机　1026．11．1　传统的虚拟化技术　1036．11．2　vagrant　1046．11．3　linux 容器　1046．11．4　docker　1066．12　一个部署接口　1076．13　小结　109第7　章 测试　1107．1　测试类型　1107．2　测试范围　1117．2．1　单元测试　1127．2．2　服务测试　1137．2．3　端到端测试　1147．2．4　权衡　1147．2．5　比例　1157．3　实现服务测试　1157．3．1　mock 还是打桩　1157．3．2　智能的打桩服务　1167．4　微妙的端到端测试　1177．5　端到端测试的缺点　1187．6　脆弱的测试　1187．6．1　谁来写这些测试　1197．6．2　测试多长时间　1197．6．3　大量的堆积　1207．6．4　元版本　1207．7　测试场景，而不是故事　1217．8　拯救消费者驱动的测试　1217．8．1　pact　1237．8．2　关于沟通　1247．9　还应该使用端到端测试吗　1247．10　部署后再测试　1257．10．1　区分部署和上线　1257．10．2　金丝雀发布　1267．10．3　平均修复时间胜过平均故障间隔时间　1277．11　跨功能的测试　1287．12　小结　129第8　章 监控　1318．1　单一服务，单一服务器　1328．2　单一服务，多个服务器　1328．3　多个服务，多个服务器　1338．4　日志，日志，更多的日志　1348．5　多个服务的指标跟踪　1358．6　服务指标　1358．7　综合监控　1368．8　关联标识　1378．9　级联　1398．10　标准化　1398．11　考虑受众　1408．12　未来　1408．13　小结　141第9　章 安全　1439．1　身份验证和授权　1439．1．1　常见的单点登录实现　1449．1．2　单点登录网关　1459．1．3　细粒度的授权　1469．2　服务间的身份验证和授权　1469．2．1　在边界内允许一切　1469．2．2　http(s) 基本身份验证　1479．2．3　使用saml 或openid connect　1489．2．4　客户端证书　1489．2．5　http 之上的hmac　1499．2．6　api 密钥　1499．2．7　代理问题　1509．3　静态数据的安全　1529．3．1　使用众所周知的加密算法　1529．3．2　一切皆与密钥相关　1539．3．3　选择你的目标　1539．3．4　按需解密　1539．3．5　加密备份　1539．4　深度防御　1549．4．1　防火墙　1549．4．2　日志　1549．4．3　入侵检测（和预防）系统　1549．4．4　网络隔离　1559．4．5　操作系统　1559．5　一个示例　1569．6　保持节俭　1589．7　人的因素　1589．8　黄金法则　1589．9　内建安全　1599．10　外部验证　1599．11　小结　159第10　章 康威定律和系统设计　16110．1　证据　16110．1．1　松耦合组织和紧耦合组织　16210．1．2　windows vista　16210．2　netflix 和amazon　16210．3　我们可以做什么　16310．4　适应沟通途径　16310．5　服务所有权　16410．6　共享服务的原因　16410．6．1　难以分割　16410．6．2　特性团队　16410．6．3　交付瓶颈　16510．7　内部开源　16610．7．1　守护者的角色　16610．7．2　成熟　16610．7．3　工具　16710．8　限界上下文和团队结构　16710．9　孤儿服务　16710．10　案例研究：realestate．com．au　16810．11　反向的康威定律　16910．12　人　17010．13　小结　170第11　章 规模化微服务　17111．1　故障无处不在　17111．2　多少是太多　17211．3　功能降级　17311．4　架构性安全措施　17411．5　反脆弱的组织　17511．5．1　超时　17611．5．2　断路器　17611．5．3　舱壁　17811．5．4　隔离　17911．6　幂等　17911．7　扩展　18011．7．1　更强大的主机　18111．7．2　拆分负载　18111．7．3　分散风险　18111．7．4　负载均衡　18211．7．5　基于worker 的系统　18411．7．6　重新设计　18411．8　扩展数据库　18511．8．1　服务的可用性和数据的持久性　18511．8．2　扩展读取　18511．8．2　扩展写操作　18611．8．4　共享数据库基础设施　18711．8．5　cqrs　18711．9　缓存　18811．9．1　客户端、 代理和服务器端缓存　18811．9．2　http 缓存　18911．9．3　为写使用缓存　19011．9．4　为弹性使用缓存　19011．9．5　隐藏源服务　19111．9．6　保持简单　19111．9．7　缓存中毒：一个警示　19211．10　自动伸缩　19211．11　cap 定理　19311．11．1　牺牲一致性　19411．11．2　牺牲可用性　19511．11．3　牺牲分区容忍性　19511．11．4　ap 还是cp　19611．11．5　这不是全部或全不　19611．11．6　真实世界　19711．12　服务发现　19711．13　动态服务注册　19911．13．1　zookeeper　19911．13．2　consul　20011．13．4　构造你自己的系统　20111．13．5　别忘了人　20111．14　文档服务　20111．14．1　swagger　20211．14．2　hal 和hal 浏览器　20211．15　自描述系统　20311．16　小结　203第12　章 总结　20412．1　微服务的原则　20412．1．1　围绕业务概念建模　20512．1．2　接受自动化文化　20512．1．3　隐藏内部实现细节　20512．1．4　让一切都去中心化　20612．1．5　可独立部署　20612．1．6　隔离失败　20612．1．7　高度可观察　20712．2　什么时候你不应该使用微服务　20712．3　临别赠言　208关于作者　209关于封面　209
