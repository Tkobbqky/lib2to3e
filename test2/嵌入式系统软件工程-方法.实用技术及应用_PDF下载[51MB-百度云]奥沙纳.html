嵌入式系统软件工程-方法.实用技术及应用 PDF下载 奥沙纳 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730242531
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730242531
<p>书名:嵌入式系统软件工程-方法.实用技术及应用</p><p>作者:奥沙纳</p><p>页数:686</p><p>定价:¥135.0</p><p>出版社:清华大学出版社</p><p>出版日期:2016-06-01</p><p>ISBN:9787302425311</p><p><h2>本书特色</h2></p>[<p>
嵌入式系统在*近几年中得到了迅速发展和广泛应用。这对嵌入式软件的可靠性、稳定性、鲁棒性和性能都提出了更高的要求，对嵌入式软件的开发也提出了新的挑战。本书讲述了嵌入式软件的重要特性和软件工程方法，例如软件设计、基于组件的开发、软件架构、系统集成和测试，以及与之配套的方法论、语言、工具和流程等。它几乎涵盖了嵌入式软件开发的所有方面，包括建模、软/硬件协同设计、操作系统、编程规范、性能与优化、集成测试、质量控制、多核软件、知识产权与项目管理等主要问题。书中列举了存储与i/o、linux与开源软件，以及面向网络和汽车的应用，*后的实例研究更可以帮助读者加深对嵌入式软件的理解。书中各章所描述的问题都是在嵌入式软件开发过程中常见的问题，每章都有对各自问题的背景介绍、问题求解以及实例和总结。这些章节各自独立，层次分明，既自成体系又互相联系。本书力求理论与实践紧密结合，内容翔实、实例丰富。本书可以作为高等院校“嵌入式软件”课程的教材，也可供从事嵌入式系统开发与应用的工程技术人员自学与参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>《嵌入式系统软件工程》是newnes“红宝书”之“专家指南”，该书为读者提供了嵌入式软件工程的方法和技术，以优化嵌入式系统的设计和实践。在处理嵌入式系统开发过程中遇到的问题时，使用软件工程的方法，将事半功倍，极大提高效率，这部由16位业界知名专家联合撰写的嵌入式软件开发著作超过120万字，是一部真正意义上的嵌入式百科全书，适合作为嵌入式系统开发者的案头工具。elsevier出版公司官网提供配套材料和教师资源。 </p>]<p><h2>作者简介</h2></p>[<p>目录
序（一）1

序（二）3

译者序5

嵌入式系统软件工程——路线图7

前言15

致谢17

关于作者19

第1章嵌入式软件工程与实时系统

1.1软件工程

1.2嵌入式系统

1.3实时系统

1.3.1实时系统的类型——软实时和硬实时系统

1.3.2硬实时系统的例子

1.3.3实时事件的特点

1.3.4有效执行与执行环境

1.4实时系统设计的挑战

1.4.1响应时间

1.4.2从故障中恢复

1.4.3嵌入式系统软件的构建过程

1.5分布式和多处理器架构

1.6嵌入式系统软件

1.7嵌入式系统的硬件抽象层

1.8小结

第2章嵌入式系统软/硬件协同开发

2.1当今嵌入式系统示例

2.2HW/SW原型机用户

2.3HW/SW原型机设计选项

2.4原型设计决策标准

2.5选择正确的原型

2.6工业设计链

2.7更改设计流程的必要

2.8不同类型的虚拟原型机

2.9虚拟原型的简要历史

2.10专有产品的限制

2.11什么使得虚拟原型机变快

2.12标准化:SystemC TLM��2.0的时代

2.13SystemC TLM��2抽象层

2.14系统架构虚拟原型机

2.15软件虚拟原型机

2.16小结——虚拟化的重要性日益增加

第3章嵌入式系统的软件建模

3.1何时、为何要为嵌入式系统建立模型

3.2建模

3.3什么是建模语言

3.4建模语言举例

3.5V图承诺

3.6为什么要建立嵌入式系统的模型

3.7何时为嵌入式系统建立模型

3.7.1任务和安全关键型应用程序

3.7.2高度复杂的应用程序和系统

3.8操作复杂性

3.9缺陷检测时间与成本

3.10大型开发团队需要建模

3.11建模通常是唯一的选择

3.12建模是有利的，但不是说所有模型都是错的吗

3.13有了原型机——又该如何

3.14结论

3.15下一步——试用

3.15.1带有直流电动机的闭环控制

3.15.2下载套件了解更多原型机设计

3.15.3使用NI状态图模块设计应用程序

3.15.4设计和模拟电刷式直流电动机H桥电路

3.15.5使用开放源代码Modelica模型进行多域物理建模

参考文献

第4章嵌入式系统的软件设计架构与模式

4.1架构和设计综述

4.2三个层次的设计

4.3什么是设计模式

4.3.1必须要采用面向对象技术来使用设计模式吗

4.3.2一个架构实例

4.3.3使用模式

4.3.4做权衡决策

4.4软件架构的类别和视图

4.4.1主要的架构视角

4.4.2次要的视角

4.5小结

参考文献

第5章实时构件： 事件与触发器

5.1事件和触发器

5.2室温控制单元

5.3事件系统

5.4事件句柄

5.5事件方法

5.6事件数据结构

5.7可重入性

5.7.1禁用和启用中断

5.7.2进入临界区和退出临界区

5.7.3信号量

5.7.4进入/退出临界区的实现

5.8事件处理

5.9集成

5.10触发器

5.11闪烁的LED

5.12设计思想

5.13嘀嗒定时器

5.14触发器接口

5.15触发器描述符

5.16数据分配

5.17设置触发器

5.18嘀嗒计数

5.19确保可重入

5.20初始化

5.21闪烁

5.22蜂鸣器鸣响

5.23实时性

5.24小结

第6章嵌入式软件的硬件接口

6.1简介

6.2与硬件团队的合作

6.2.1主动合作

6.2.2团队代表

6.2.3注册设计工具

6.2.4共同开发

6.2.5系统集成

6.3硬件设计方面有用的知识

6.3.1硬件事件的通知

6.3.2向硬件下达任务

6.3.3位域对齐

6.3.4固定位的位置

6.3.5模块版本号

6.3.6调试钩子

6.4支持多个硬件版本

6.4.1编译开关

6.4.2构建开关

6.4.3运行开关

6.4.4自适应开关

6.5硬件交互困难

6.5.1原子寄存器访问

6.5.2同一寄存器中混合的位类型

6.5.3边沿与电平中断

6.6测试与故障排除

6.6.1临时钩子

6.6.2永久钩子

6.7小结

第7章嵌入式软件编程和实现准则

7.1简介

7.1.1高质量编程的原则

7.1.2是什么让嵌入式不同于一般编程

7.2启动嵌入式软件项目

7.2.1硬件平台输入

7.2.2工程文件和组织

7.2.3团队编程指南

7.2.4语法标准

7.2.5源代码中的安全要求

7.3变量结构

7.3.1变量声明

7.3.2数据类型

7.3.3定义

第8章嵌入式操作系统

8.1前台/后台系统

8.2实时内核

8.2.1RTOS(实时操作系统)

8.2.2临界区

8.2.3任务管理

8.2.4分配任务优先级

8.2.5决定堆栈的大小

8.2.6空闲任务

8.3优先级

8.4就绪队列

8.5调度点

8.6上下文切换

8.7中断管理

8.7.1处理CPU中断

8.7.2非内核感知的中断服务程序

8.7.3拥有多种中断优先级的处理器

8.7.4所有的中断向量的共同地址

8.7.5每个中断向量对应唯一的地址

8.8时钟周期(或系统时钟周期)

8.9等待队列

8.10时间管理

8.11资源管理

8.11.1资源管理： 禁用/启用中断

8.11.2资源管理: 信号量

8.11.3资源管理： 优先级反转

8.11.4资源管理： 互斥信号量

8.11.5资源管理： 僵局(死锁)

8.12同步

8.12.1同步： 信号量

8.12.2同步： 信用跟踪

8.12.3双方相约

8.13消息传递

8.13.1消息

8.13.2消息队列

8.13.3流控制

8.13.4客户端和服务器端

8.14内存管理

8.15小结

第9章嵌入式系统设计的软件复用

9.1为什么软件复用如此重要

9.2什么限制了软件复用

9.3各种软件复用

9.4通过层实现复用

9.5进入到下一个级别

9.6引入元件厂

9.7工厂硬件配置

9.8工厂软件配置

9.9工厂对可复用性的作用

9.10RTOS不可知论

9.11任意扩展性

9.12结论

参考文献

第10章嵌入式系统的软件性能工程

10.1示例： eNodeB应用程序的延迟时间与吞吐量对比

10.2性能模式和反模式

参考文献

第11章嵌入式软件的性能优化

11.1代码优化过程

11.2使用开发工具

11.2.1编译器的优化

11.2.2基本的编译器配置

11.2.3启用优化

11.2.4附加的优化配置

11.2.5使用分析器

11.3背景——理解嵌入式架构

11.4基本的C优化技术

11.4.1选择正确的数据类型

11.4.2函数的调用规范

11.4.3指针和内存访问

11.4.4限制和指针别名

11.4.5循环

11.4.6额外的提示和技巧

11.5一般循环转换

11.5.1循环展开

11.5.2多采样技术

11.5.3部分求和

11.5.4软件流水线

11.6优化技术的实例应用： 互相关

11.6.1设置

11.6.2原始实例

第12章嵌入式软件的内存优化

12.1简介

12.2代码大小的优化

12.2.1编译标志位和标志位挖掘

12.2.2目标ISA的大小和性能的折中

12.2.3为代码大小调整ABI

12.2.4买者自负： 编译器优化正交码的大小

12.3内存布局优化

12.3.1内存优化简介

12.3.2重点优化

12.3.3向量化和动态代码： 计算比率

12.3.4C语言指针别名

12.4数据结构、数据结构的数组及其添加

12.5内存性能的循环优化

12.5.1数据对齐的连锁效应

12.5.2选择数据类型的益处

第13章嵌入式软件的功耗优化

13.1简介

13.2理解功耗

13.2.1功耗的基本概念

13.2.2静态与动态功率消耗

13.2.3最大功率、平均功率、最坏情况功率和典型功率

13.3测量功耗

13.3.1使用电流表测量功率

13.3.2使用霍尔传感器芯片测量功率

13.3.3VRMs(电压调整模块的电源芯片)

13.3.4静态功率测量

13.3.5动态功率测量

13.3.6分析应用的功率消耗

13.4最小化功耗

13.4.1硬件支持

13.4.2时钟控制和电压控制

13.4.3低功耗示例

13.5优化数据流

13.5.1减少存储器访问的功率消耗

13.5.2DDR简介

13.5.3优化DDR数据流功耗

13.5.4通过时序优化功率

13.5.5通过交替方式优化

13.5.6优化存储器的软件数据组织

13.5.7优化通用DDR配置

13.5.8优化DDR burst访问

13.6SRAM和高速缓存数据流的功率优化

13.6.1SRAM(所有存储器)与代码大小

13.6.2SRAM功率消耗和并行处理

13.6.3数据转换与功率消耗

13.6.4高速缓存的使用与SoC存储器布局

13.6.5局部性说明

13.6.6集合关联说明

13.6.7高速缓存布局

13.6.8回写高速缓存与直写式高速缓存

13.6.9高速缓存一致性功能

13.6.10编译器优化高速缓存

13.7外设/通信使用

13.7.1数据DMA与CPU

13.7.2协处理器

13.7.3系统总线配置

13.7.4外设速度等级和总线宽度

13.7.5外设到内核的通信

13.8算法

13.8.1编译器优化级别

13.8.2指令打包

13.8.3探讨循环展开

13.8.4软件流水处理

13.8.5禁止递归

13.8.6降低精度

13.8.7低功率代码序列和数据模式

13.9小结

第14章嵌入式系统中的用户界面设计

14.1用户界面设计分析阶段

14.1.1初步迭代设计

14.1.2第二个原型的开发(高保真工具绘制模型)

14.1.3基本的应用案例

14.1.4用户分析方案

14.1.5层次任务分析

14.1.6设计克服用户认识、感知及学习时的局限性的途径

14.1.7错误信息

14.2虚拟窗口

14.3使用实体关系图的数据模型

14.4使用CREDO试验矩阵来分析虚拟窗口

14.5启发式评估

14.6格式塔

14.7应用模型—视图—控制器体系结构设计用户界面

14.7.1MVC软件体系架构

14.7.2关于MVC软件体系结构的问题及展望

14.7.3使用MVC的解决方案

14.8对安全性要求苛刻的用户界面

14.8.1更加安全的HMI设计过程

14.8.2人机界面设计安全手册

参考文献

第15章嵌入式软件质量、集成和测试技术

15.1什么是软件测试

15.1.1为什么要测试软件

15.1.2多少测试就足够了

15.1.3应该何时进行测试

15.1.4谁来做决策

15.2可用的技术

15.2.1静态和动态分析

15.2.2需求追踪

15.2.3静态分析——遵循编码标准

15.2.4基本结与基本圈复杂度——案例研究

15.2.5理解动态分析

15.2.6继承高完整性的系统

15.2.7定义单元、模块和集成测试

15.2.8定义结构化覆盖分析

15.2.9结合单元测试和系统测试来实现代码覆盖

15.2.10通过回归测试保持功能

15.2.11单元测试和由测试驱动的开发

15.2.12自动生成测试用例

15.3设置标准

15.3.1标准的术语

15.3.2公认的流程标准的演变

15.3.3自由选择适当的标准

15.3.4建立内部的流程标准

15.3.5建立内部编码规范集的公共基础

15.3.6处理现有的代码库

15.3.7获得自定义软件开发的内部编码标准——案例研究

15.4处理异常

15.4.1处理自动生成的代码

15.4.2处理继承的代码

15.4.3通过目标代码验证跟踪需求

15.5实施测试解决方案的环境

15.5.1实用主义的考虑

15.5.2考虑备选方案

15.6小结

第16章嵌入式系统的软件开发工具

16.1调试工具简介

16.2GDB调试

16.2.1GDB调试器的配置

16.2.2启动GDB

16.2.3编译应用程序

16.2.4调试应用程序

16.2.5检查数据

16.2.6使用断点

16.2.7步进

16.2.8更改程序

16.2.9分析内核转储

16.3调试代理设计

16.3.1使用案例

16.3.2调试代理简介

16.3.3启动应用程序

16.3.4上下文切换

16.3.5位置独立的可执行文件

16.3.6来自应用程序的调试事件

16.3.7多核

16.3.8启动调试代理

16.4使用JTAG调试

16.4.1使用JTAG的好处

16.4.2使用JTAG启动主板

16.4.3与调试代理的比较

16.4.4GDB和JTAG

16.5使用Eclipse和GDB的调试工具

16.5.1使用GDB调试Linux应用程序

16.5.2Linux内核的KGDB调试

16.6检测代码

16.7分析工具

16.7.1strace

16.7.2mtrace

16.7.3Valgrind

16.8硬件功能

16.8.1硬件断点

16.8.2硬件监视点

16.9调试提示和技巧

第17章嵌入式系统的多核软件开发

17.1分析和高层设计

17.1.1分析

17.1.2高层次设计

17.1.3小结

17.2实现和低层次设计

17.2.1基于线程的实现

17.2.2互斥、锁、嵌套锁

17.2.3粒度

17.2.4实现任务并行

17.2.5消息传递实现

17.2.6使用混合方法

参考文献

第18章安全关键软件的开发

18.1引言

18.2有哪些安全需求

18.3项目规划策略

18.4故障、失效、危害和风险分析

18.4.1故障、错误和失效

18.4.2可用性和可靠性

18.4.3故障处理

18.4.4危害分析

18.4.5风险分析

18.5安全关键的架构

18.6软件实施策略

参考文献

第19章知识产权

19.1背景

19.2软件属于你吗

19.2.1获得软件

19.2.2版权保护

19.2.3获得版权

19.3专利

19.3.1什么是专利

19.3.2为什么会有专利

19.3.3决定为哪些部分申请专利

19.3.4申请专利

19.3.5专利里都有什么

19.3.6专利授权

19.4问题

19.4.1开源软件

19.4.2授权和出售软件

19.4.3收购

19.4.4发现侵权

19.4.5避免版权侵权

19.4.6避免专利侵权

第20章管理嵌入式软件开发

20.1能力成熟度模型集成

20.2OSI模型

20.3软件开发

20.3.1V模型

20.3.2瀑布模型

20.3.3敏捷模型

20.4组织

20.5项目纲领

20.6利益相关者和核心团队

20.7产品生命周期管理

20.8组合管理

20.9项目管理生命周期

20.10项目生命周期

20.11解决问题

20.12沟通

20.13缩写，符号，首字母缩略词

20.14版权确认

参考文献

第21章嵌入式系统的敏捷开发

21.1引言

21.2嵌入式系统有什么特殊之处

21.3嵌入式系统的敏捷项目规划

21.3.1项目展望

21.3.2初始安全性/可靠性风险评估

21.3.3初始项目风险评估

21.3.4估算

21.3.5进度安排

21.4嵌入式软件项目管理

21.4.1站立(会议)

21.4.2性能指标

24.4.3迭代回溯(共同的阶段)

21.5嵌入式敏捷开发实践

21.6敏捷规模因素

21.7敏捷方法能帮助你遵守标准吗

21.8小结

参考文献

第22章嵌入式软件在汽车领域中的应用

22.1发展历史

22.1.1汽车电子： 1911—2000

22.1.2电子内容增长的驱动力

22.1.3引发的嵌入式软件增长

22.1.4汽车编程语言

22.1.5小结

22.2汽车的各部分及其区别

22.2.1车身

22.2.2底盘和安全

22.2.3辅助驾驶

22.2.4动力总成和变速器

22.2.5信息娱乐和远程信息处理

22.2.6汽车子部分总结

22.3汽车质量

22.3.1基于墨菲定律制定计划

22.3.2容错通信

22.3.3容错软件

22.3.4零缺陷软件

22.3.5风险管理和故障模式

22.3.6失效模式和影响分析

22.4开发和测试

22.4.1子系统的互操作性

22.4.2软件规范

22.4.3软件体系结构

22.4.4建模

22.4.5自动编码与驱动程序

22.4.6基准测试

22.4.7跟踪和调试

22.4.8最后阶段的测试                     

22.4.9校验

22.4.10维护/在产品生命周期内支持

22.5汽车诊断

22.5.1故障指示灯

22.5.2数据记录器

22.5.3第二代车载诊断

22.6汽车标准

22.6.1汽车工业软件可靠性协会

22.6.2汽车开放系统体系结构

22.6.3汽车电子委员会

22.7汽车安全

22.7.1ISO 26262标准

22.7.2汽车安全完整性等级

22.8汽车防盗

22.8.1过去这意味着：汽车警报器等

22.8.2现在这意味着： 黑客行为

22.8.3未来这将意味着： 假冒

22.9汽车市场不久的未来

22.9.1性能

22.9.2多核的出现

22.9.3车载终端

22.9.4自动汽车

22.10小结

第23章I/O及存储设备编程

23.1I/O设备与I/O控制器

23.1.1I/O设备的分类

23.1.2I/O控制器

23.1.3内存映射与DMA

23.1.4闪存、SD/SDHC与硬盘驱动器

23.1.5网络附加存储

23.2I/O编程

23.2.1I/O控制模式

23.2.2I/O软件目标

23.2.3I/O软件层

23.2.4案例研究： Linux设备驱动程序

23.3存储编程

23.3.1I/O用于块设备

23.3.2闪存设备编程

23.3.3SATA设备驱动程序

23.4存储系统性能改善

23.4.1案例研究1： SDHC上的性能优化

23.4.2案例研究2： NAS上的性能优化

23.5小结

参考文献

第24章网络应用的嵌入式软件

24.1引言

24.2网络设备的系统结构

24.3网络多核SoC

24.3.1核心

24.3.2数据包引擎的硬件(PEH)块

24.4网络编程模型

24.5数据包处理软件的结构

24.5.1数据层面的基础设施(DP红外线)

24.5.2转发引擎的结构

24.5.3数据包处理应用的要求

24.6网络应用编程技术

24.6.1网络应用程序员可以使用的多核性能技术

24.6.2查找流上下文时避免使用锁

24.6.3避免引用计数

24.6.4安全引用机制

24.6.5流并行

24.6.6减少与更新统计数据相关的缓存冲突

24.6.7统计数据加速

24.7网络应用程序员常用的性能技术

24.8嵌入式网络设备的Linux操作系统

24.9小结

第25章嵌入式Linux操作系统

25.1简介

25.1.1选择Linux进行嵌入式系统开发的原因

25.1.2Linux发行版

25.1.3适用于Linux的嵌入式平台

25.1.4许可

25.2嵌入式Linux入门

25.2.1内存管理单元

25.2.2启动载入器

25.2.3引导装载程序

25.2.4内核

25.2.5应用程序

25.3在参考板上运行Linux

25.3.1参考平台

25.3.2从BeagleBone入手

附录AC语言编码标准： 源代码的发展

A.1适用范围

A.2定义

A.3规则与约定

A.3.1显示格式

A.3.2命名

A.3.3执行语句限制

A.3.4语言结构与特征

A.4复杂性

A.5问题构建

A.6源和include文件布局

A.7特性

A.8标准缩写

A.9建议的模块名

A.10源代码模板

A.11标准的包含文件模板

A.12portable.h包含文件模板

A.13函数模板

附录BC  在嵌入式软件、系统与平台方面的使用

B.1C  对于嵌入式相对廉价的特性

B.2C  对于嵌入式稍微昂贵的特性

B.3C  对于嵌入式昂贵的特性

案例研究1软件性能工程

CS1.1项目简介和说明

CS1.2初始性能评估与信息要求

CS1.3开发初始评估

CS1.4跟踪报告指标

CS1.5减少测量误差

CS1.6经验教训与总结

参考文献

案例研究2用户界面设计： 警务指挥与控制系统

CS2.1案例简介

CS2.2警务指挥与控制系统

CS2.2.1警务指挥与控制系统的说明和概念模型

CS2.2.2系统数据收集方法

CS2.2.3系统用例图和用例场景

CS2.3重要用例

CS2.4场景

CS2.4.1警务指挥和控制的用户界面场景(完美场景)

CS2.4.2不完美的场景

CS2.4.3警务指挥和控制系统的典型用户场景

CS2.5层次任务分析

CS2.6警务指挥和控制系统的主要交互方式

CS2.7克服用户认知、感知和学习限制的设计方法

CS2.8克服用户局限性的外部认知方法

CS2.9警务指挥和控制系统的报错信息和警告

CS2.10数据模型(实体关系图)与警务指挥和控制系统中的虚拟操作系统

CS2.11识别警务指挥和控制系统用户界面设计中的完全形态

CS2.12数据显示技术

CS2.13第一原型的易用性测试

CS2.14二次迭代——低保真原型

CS2.14.1为低保真原型第二次迭代所做的易用性测试和缺陷矫正

CS2.14.2低保真原型的最终版

CS2.14.3支持从新手到专家的过渡

CS2.15高保真原型

CS2.16快速开始向导

案例研究3转化为多核

CS3.1典型应用软件简介

CS3.2软件系统分区

CS3.2.1控制层面软件迁移

CS3.2.2数据层面软件迁移

CS3.3数据包的并行处理

CS3.4混合方法(并行加流水线)

CS3.5与控制层面分区的数据通信

CS3.6管理代理

CS3.7Rx/Tx驱动器

案例研究4嵌入式系统质量和衡量计划的软件工程

CS4.1开发方法

CS4.2度量收集

CS4.3小结</p>]<p><h2>目录</h2></p>
    目录序（一）1序（二）3译者序5嵌入式系统软件工程——路线图7前言15致谢17关于作者19第1章嵌入式软件工程与实时系统1.1软件工程1.2嵌入式系统1.3实时系统1.3.1实时系统的类型——软实时和硬实时系统1.3.2硬实时系统的例子1.3.3实时事件的特点1.3.4有效执行与执行环境1.4实时系统设计的挑战1.4.1响应时间1.4.2从故障中恢复1.4.3嵌入式系统软件的构建过程1.5分布式和多处理器架构1.6嵌入式系统软件1.7嵌入式系统的硬件抽象层1.8小结第2章嵌入式系统软/硬件协同开发2.1当今嵌入式系统示例2.2hw/sw原型机用户2.3hw/sw原型机设计选项2.4原型设计决策标准2.5选择正确的原型2.6工业设计链2.7更改设计流程的必要2.8不同类型的虚拟原型机2.9虚拟原型的简要历史2.10专有产品的限制2.11什么使得虚拟原型机变快2.12标准化:systemc tlm��2.0的时代2.13systemc tlm��2抽象层2.14系统架构虚拟原型机2.15软件虚拟原型机2.16小结——虚拟化的重要性日益增加第3章嵌入式系统的软件建模3.1何时、为何要为嵌入式系统建立模型3.2建模3.3什么是建模语言3.4建模语言举例3.5v图承诺3.6为什么要建立嵌入式系统的模型3.7何时为嵌入式系统建立模型3.7.1任务和安全关键型应用程序3.7.2高度复杂的应用程序和系统3.8操作复杂性3.9缺陷检测时间与成本3.10大型开发团队需要建模3.11建模通常是唯一的选择3.12建模是有利的，但不是说所有模型都是错的吗3.13有了原型机——又该如何3.14结论3.15下一步——试用3.15.1带有直流电动机的闭环控制3.15.2下载套件了解更多原型机设计3.15.3使用ni状态图模块设计应用程序3.15.4设计和模拟电刷式直流电动机h桥电路3.15.5使用开放源代码modelica模型进行多域物理建模参考文献第4章嵌入式系统的软件设计架构与模式4.1架构和设计综述4.2三个层次的设计4.3什么是设计模式4.3.1必须要采用面向对象技术来使用设计模式吗4.3.2一个架构实例4.3.3使用模式4.3.4做权衡决策4.4软件架构的类别和视图4.4.1主要的架构视角4.4.2次要的视角4.5小结参考文献第5章实时构件： 事件与触发器5.1事件和触发器5.2室温控制单元5.3事件系统5.4事件句柄5.5事件方法5.6事件数据结构5.7可重入性5.7.1禁用和启用中断5.7.2进入临界区和退出临界区5.7.3信号量5.7.4进入/退出临界区的实现5.8事件处理5.9集成5.10触发器5.11闪烁的led5.12设计思想5.13嘀嗒定时器5.14触发器接口5.15触发器描述符5.16数据分配5.17设置触发器5.18嘀嗒计数5.19确保可重入5.20初始化5.21闪烁5.22蜂鸣器鸣响5.23实时性5.24小结第6章嵌入式软件的硬件接口6.1简介6.2与硬件团队的合作6.2.1主动合作6.2.2团队代表6.2.3注册设计工具6.2.4共同开发6.2.5系统集成6.3硬件设计方面有用的知识6.3.1硬件事件的通知6.3.2向硬件下达任务6.3.3位域对齐6.3.4固定位的位置6.3.5模块版本号6.3.6调试钩子6.4支持多个硬件版本6.4.1编译开关6.4.2构建开关6.4.3运行开关6.4.4自适应开关6.5硬件交互困难6.5.1原子寄存器访问6.5.2同一寄存器中混合的位类型6.5.3边沿与电平中断6.6测试与故障排除6.6.1临时钩子6.6.2永久钩子6.7小结第7章嵌入式软件编程和实现准则7.1简介7.1.1高质量编程的原则7.1.2是什么让嵌入式不同于一般编程7.2启动嵌入式软件项目7.2.1硬件平台输入7.2.2工程文件和组织7.2.3团队编程指南7.2.4语法标准7.2.5源代码中的安全要求7.3变量结构7.3.1变量声明7.3.2数据类型7.3.3定义第8章嵌入式操作系统8.1前台/后台系统8.2实时内核8.2.1rtos(实时操作系统)8.2.2临界区8.2.3任务管理8.2.4分配任务优先级8.2.5决定堆栈的大小8.2.6空闲任务8.3优先级8.4就绪队列8.5调度点8.6上下文切换8.7中断管理8.7.1处理cpu中断8.7.2非内核感知的中断服务程序8.7.3拥有多种中断优先级的处理器8.7.4所有的中断向量的共同地址8.7.5每个中断向量对应唯一的地址8.8时钟周期(或系统时钟周期)8.9等待队列8.10时间管理8.11资源管理8.11.1资源管理： 禁用/启用中断8.11.2资源管理: 信号量8.11.3资源管理： 优先级反转8.11.4资源管理： 互斥信号量8.11.5资源管理： 僵局(死锁)8.12同步8.12.1同步： 信号量8.12.2同步： 信用跟踪8.12.3双方相约8.13消息传递8.13.1消息8.13.2消息队列8.13.3流控制8.13.4客户端和服务器端8.14内存管理8.15小结第9章嵌入式系统设计的软件复用9.1为什么软件复用如此重要9.2什么限制了软件复用9.3各种软件复用9.4通过层实现复用9.5进入到下一个级别9.6引入元件厂9.7工厂硬件配置9.8工厂软件配置9.9工厂对可复用性的作用9.10rtos不可知论9.11任意扩展性9.12结论参考文献第10章嵌入式系统的软件性能工程10.1示例： enodeb应用程序的延迟时间与吞吐量对比10.2性能模式和反模式参考文献第11章嵌入式软件的性能优化11.1代码优化过程11.2使用开发工具11.2.1编译器的优化11.2.2基本的编译器配置11.2.3启用优化11.2.4附加的优化配置11.2.5使用分析器11.3背景——理解嵌入式架构11.4基本的c优化技术11.4.1选择正确的数据类型11.4.2函数的调用规范11.4.3指针和内存访问11.4.4限制和指针别名11.4.5循环11.4.6额外的提示和技巧11.5一般循环转换11.5.1循环展开11.5.2多采样技术11.5.3部分求和11.5.4软件流水线11.6优化技术的实例应用： 互相关11.6.1设置11.6.2原始实例第12章嵌入式软件的内存优化12.1简介12.2代码大小的优化12.2.1编译标志位和标志位挖掘12.2.2目标isa的大小和性能的折中12.2.3为代码大小调整abi12.2.4买者自负： 编译器优化正交码的大小12.3内存布局优化12.3.1内存优化简介12.3.2重点优化12.3.3向量化和动态代码： 计算比率12.3.4c语言指针别名12.4数据结构、数据结构的数组及其添加12.5内存性能的循环优化12.5.1数据对齐的连锁效应12.5.2选择数据类型的益处第13章嵌入式软件的功耗优化13.1简介13.2理解功耗13.2.1功耗的基本概念13.2.2静态与动态功率消耗13.2.3*大功率、平均功率、*坏情况功率和典型功率13.3测量功耗13.3.1使用电流表测量功率13.3.2使用霍尔传感器芯片测量功率13.3.3vrms(电压调整模块的电源芯片)13.3.4静态功率测量13.3.5动态功率测量13.3.6分析应用的功率消耗13.4*小化功耗13.4.1硬件支持13.4.2时钟控制和电压控制13.4.3低功耗示例13.5优化数据流13.5.1减少存储器访问的功率消耗13.5.2ddr简介13.5.3优化ddr数据流功耗13.5.4通过时序优化功率13.5.5通过交替方式优化13.5.6优化存储器的软件数据组织13.5.7优化通用ddr配置13.5.8优化ddr burst访问13.6sram和高速缓存数据流的功率优化13.6.1sram(所有存储器)与代码大小13.6.2sram功率消耗和并行处理13.6.3数据转换与功率消耗13.6.4高速缓存的使用与soc存储器布局13.6.5局部性说明13.6.6集合关联说明13.6.7高速缓存布局13.6.8回写高速缓存与直写式高速缓存13.6.9高速缓存一致性功能13.6.10编译器优化高速缓存13.7外设/通信使用13.7.1数据dma与cpu13.7.2协处理器13.7.3系统总线配置13.7.4外设速度等级和总线宽度13.7.5外设到内核的通信13.8算法13.8.1编译器优化级别13.8.2指令打包13.8.3探讨循环展开13.8.4软件流水处理13.8.5禁止递归13.8.6降低精度13.8.7低功率代码序列和数据模式13.9小结第14章嵌入式系统中的用户界面设计14.1用户界面设计分析阶段14.1.1初步迭代设计14.1.2第二个原型的开发(高保真工具绘制模型)14.1.3基本的应用案例14.1.4用户分析方案14.1.5层次任务分析14.1.6设计克服用户认识、感知及学习时的局限性的途径14.1.7错误信息14.2虚拟窗口14.3使用实体关系图的数据模型14.4使用credo试验矩阵来分析虚拟窗口14.5启发式评估14.6格式塔14.7应用模型—视图—控制器体系结构设计用户界面14.7.1mvc软件体系架构14.7.2关于mvc软件体系结构的问题及展望14.7.3使用mvc的解决方案14.8对安全性要求苛刻的用户界面14.8.1更加安全的hmi设计过程14.8.2人机界面设计安全手册参考文献第15章嵌入式软件质量、集成和测试技术15.1什么是软件测试15.1.1为什么要测试软件15.1.2多少测试就足够了15.1.3应该何时进行测试15.1.4谁来做决策15.2可用的技术15.2.1静态和动态分析15.2.2需求追踪15.2.3静态分析——遵循编码标准15.2.4基本结与基本圈复杂度——案例研究15.2.5理解动态分析15.2.6继承高完整性的系统15.2.7定义单元、模块和集成测试15.2.8定义结构化覆盖分析15.2.9结合单元测试和系统测试来实现代码覆盖15.2.10通过回归测试保持功能15.2.11单元测试和由测试驱动的开发15.2.12自动生成测试用例15.3设置标准15.3.1标准的术语15.3.2公认的流程标准的演变15.3.3自由选择适当的标准15.3.4建立内部的流程标准15.3.5建立内部编码规范集的公共基础15.3.6处理现有的代码库15.3.7获得自定义软件开发的内部编码标准——案例研究15.4处理异常15.4.1处理自动生成的代码15.4.2处理继承的代码15.4.3通过目标代码验证跟踪需求15.5实施测试解决方案的环境15.5.1实用主义的考虑15.5.2考虑备选方案15.6小结第16章嵌入式系统的软件开发工具16.1调试工具简介16.2gdb调试16.2.1gdb调试器的配置16.2.2启动gdb16.2.3编译应用程序16.2.4调试应用程序16.2.5检查数据16.2.6使用断点16.2.7步进16.2.8更改程序16.2.9分析内核转储16.3调试代理设计16.3.1使用案例16.3.2调试代理简介16.3.3启动应用程序16.3.4上下文切换16.3.5位置独立的可执行文件16.3.6来自应用程序的调试事件16.3.7多核16.3.8启动调试代理16.4使用jtag调试16.4.1使用jtag的好处16.4.2使用jtag启动主板16.4.3与调试代理的比较16.4.4gdb和jtag16.5使用eclipse和gdb的调试工具16.5.1使用gdb调试linux应用程序16.5.2linux内核的kgdb调试16.6检测代码16.7分析工具16.7.1strace16.7.2mtrace16.7.3valgrind16.8硬件功能16.8.1硬件断点16.8.2硬件监视点16.9调试提示和技巧第17章嵌入式系统的多核软件开发17.1分析和高层设计17.1.1分析17.1.2高层次设计17.1.3小结17.2实现和低层次设计17.2.1基于线程的实现17.2.2互斥、锁、嵌套锁17.2.3粒度17.2.4实现任务并行17.2.5消息传递实现17.2.6使用混合方法参考文献第18章安全关键软件的开发18.1引言18.2有哪些安全需求18.3项目规划策略18.4故障、失效、危害和风险分析18.4.1故障、错误和失效18.4.2可用性和可靠性18.4.3故障处理18.4.4危害分析18.4.5风险分析18.5安全关键的架构18.6软件实施策略参考文献第19章知识产权19.1背景19.2软件属于你吗19.2.1获得软件19.2.2版权保护19.2.3获得版权19.3专利19.3.1什么是专利19.3.2为什么会有专利19.3.3决定为哪些部分申请专利19.3.4申请专利19.3.5专利里都有什么19.3.6专利授权19.4问题19.4.1开源软件19.4.2授权和出售软件19.4.3收购19.4.4发现侵权19.4.5避免版权侵权19.4.6避免专利侵权第20章管理嵌入式软件开发20.1能力成熟度模型集成20.2osi模型20.3软件开发20.3.1v模型20.3.2瀑布模型20.3.3敏捷模型20.4组织20.5项目纲领20.6利益相关者和核心团队20.7产品生命周期管理20.8组合管理20.9项目管理生命周期20.10项目生命周期20.11解决问题20.12沟通20.13缩写，符号，首字母缩略词20.14版权确认参考文献第21章嵌入式系统的敏捷开发21.1引言21.2嵌入式系统有什么特殊之处21.3嵌入式系统的敏捷项目规划21.3.1项目展望21.3.2初始安全性/可靠性风险评估21.3.3初始项目风险评估21.3.4估算21.3.5进度安排21.4嵌入式软件项目管理21.4.1站立(会议)21.4.2性能指标24.4.3迭代回溯(共同的阶段)21.5嵌入式敏捷开发实践21.6敏捷规模因素21.7敏捷方法能帮助你遵守标准吗21.8小结参考文献第22章嵌入式软件在汽车领域中的应用22.1发展历史22.1.1汽车电子： 1911—200022.1.2电子内容增长的驱动力22.1.3引发的嵌入式软件增长22.1.4汽车编程语言22.1.5小结22.2汽车的各部分及其区别22.2.1车身22.2.2底盘和安全22.2.3辅助驾驶22.2.4动力总成和变速器22.2.5信息娱乐和远程信息处理22.2.6汽车子部分总结22.3汽车质量22.3.1基于墨菲定律制定计划22.3.2容错通信22.3.3容错软件22.3.4零缺陷软件22.3.5风险管理和故障模式22.3.6失效模式和影响分析22.4开发和测试22.4.1子系统的互操作性22.4.2软件规范22.4.3软件体系结构22.4.4建模22.4.5自动编码与驱动程序22.4.6基准测试22.4.7跟踪和调试22.4.8*后阶段的测试                     22.4.9校验22.4.10维护/在产品生命周期内支持22.5汽车诊断22.5.1故障指示灯22.5.2数据记录器22.5.3第二代车载诊断22.6汽车标准22.6.1汽车工业软件可靠性协会22.6.2汽车开放系统体系结构22.6.3汽车电子委员会22.7汽车安全22.7.1iso 26262标准22.7.2汽车安全完整性等级22.8汽车防盗22.8.1过去这意味着：汽车警报器等22.8.2现在这意味着： 黑客行为22.8.3未来这将意味着： 假冒22.9汽车市场不久的未来22.9.1性能22.9.2多核的出现22.9.3车载终端22.9.4自动汽车22.10小结第23章i/o及存储设备编程23.1i/o设备与i/o控制器23.1.1i/o设备的分类23.1.2i/o控制器23.1.3内存映射与dma23.1.4闪存、sd/sdhc与硬盘驱动器23.1.5网络附加存储23.2i/o编程23.2.1i/o控制模式23.2.2i/o软件目标23.2.3i/o软件层23.2.4案例研究： linux设备驱动程序23.3存储编程23.3.1i/o用于块设备23.3.2闪存设备编程23.3.3sata设备驱动程序23.4存储系统性能改善23.4.1案例研究1： sdhc上的性能优化23.4.2案例研究2： nas上的性能优化23.5小结参考文献第24章网络应用的嵌入式软件24.1引言24.2网络设备的系统结构24.3网络多核soc24.3.1核心24.3.2数据包引擎的硬件(peh)块24.4网络编程模型24.5数据包处理软件的结构24.5.1数据层面的基础设施(dp红外线)24.5.2转发引擎的结构24.5.3数据包处理应用的要求24.6网络应用编程技术24.6.1网络应用程序员可以使用的多核性能技术24.6.2查找流上下文时避免使用锁24.6.3避免引用计数24.6.4安全引用机制24.6.5流并行24.6.6减少与更新统计数据相关的缓存冲突24.6.7统计数据加速24.7网络应用程序员常用的性能技术24.8嵌入式网络设备的linux操作系统24.9小结第25章嵌入式linux操作系统25.1简介25.1.1选择linux进行嵌入式系统开发的原因25.1.2linux发行版25.1.3适用于linux的嵌入式平台25.1.4许可25.2嵌入式linux入门25.2.1内存管理单元25.2.2启动载入器25.2.3引导装载程序25.2.4内核25.2.5应用程序25.3在参考板上运行linux25.3.1参考平台25.3.2从beaglebone入手附录ac语言编码标准： 源代码的发展a.1适用范围a.2定义a.3规则与约定a.3.1显示格式a.3.2命名a.3.3执行语句限制a.3.4语言结构与特征a.4复杂性a.5问题构建a.6源和include文件布局a.7特性a.8标准缩写a.9建议的模块名a.10源代码模板a.11标准的包含文件模板a.12portable.h包含文件模板a.13函数模板附录bc  在嵌入式软件、系统与平台方面的使用b.1c  对于嵌入式相对廉价的特性b.2c  对于嵌入式稍微昂贵的特性b.3c  对于嵌入式昂贵的特性案例研究1软件性能工程cs1.1项目简介和说明cs1.2初始性能评估与信息要求cs1.3开发初始评估cs1.4跟踪报告指标cs1.5减少测量误差cs1.6经验教训与总结参考文献案例研究2用户界面设计： 警务指挥与控制系统cs2.1案例简介cs2.2警务指挥与控制系统cs2.2.1警务指挥与控制系统的说明和概念模型cs2.2.2系统数据收集方法cs2.2.3系统用例图和用例场景cs2.3重要用例cs2.4场景cs2.4.1警务指挥和控制的用户界面场景(完美场景)cs2.4.2不完美的场景cs2.4.3警务指挥和控制系统的典型用户场景cs2.5层次任务分析cs2.6警务指挥和控制系统的主要交互方式cs2.7克服用户认知、感知和学习限制的设计方法cs2.8克服用户局限性的外部认知方法cs2.9警务指挥和控制系统的报错信息和警告cs2.10数据模型(实体关系图)与警务指挥和控制系统中的虚拟操作系统cs2.11识别警务指挥和控制系统用户界面设计中的完全形态cs2.12数据显示技术cs2.13**原型的易用性测试cs2.14二次迭代——低保真原型cs2.14.1为低保真原型第二次迭代所做的易用性测试和缺陷矫正cs2.14.2低保真原型的*终版cs2.14.3支持从新手到专家的过渡cs2.15高保真原型cs2.16快速开始向导案例研究3转化为多核cs3.1典型应用软件简介cs3.2软件系统分区cs3.2.1控制层面软件迁移cs3.2.2数据层面软件迁移cs3.3数据包的并行处理cs3.4混合方法(并行加流水线)cs3.5与控制层面分区的数据通信cs3.6管理代理cs3.7rx/tx驱动器案例研究4嵌入式系统质量和衡量计划的软件工程cs4.1开发方法cs4.2度量收集cs4.3小结
