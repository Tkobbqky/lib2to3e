大话计算机-计算机系统底层架构原理极限剖析-(全三册) PDF下载 冬瓜哥 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730252647
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730252647
<p>书名:大话计算机-计算机系统底层架构原理极限剖析-(全三册)</p><p>作者:冬瓜哥</p><p>页数:未知</p><p>定价:¥598.0</p><p>出版社:清华大学出版社</p><p>出版日期:2019-05-01</p><p>ISBN:9787302526476</p><p><h2>本书特色</h2></p>[<p>
<br/> 本书共分为12章。第1章介绍数字计算机的设计思路，制作一个按键计算器，在这个过程中逐步理解数字计<br/>算机底层原理。第2章在第1章的基础上，改造按键计算器，实现能够按照编好的程序自动计算，并介绍对应的处<br/>理器内部架构概念。第3章介绍电子计算机的发展史，包括芯片制造等内容。第4章介绍流水线相关知识，包括流<br/>水线、分支预测、乱序执行、超标量等内容。第5章介绍计算机程序架构，理解单个、多个程序如何在处理器上编<br/>译、链接并*终运行的过程。第6章介绍缓存以及多处理器并行执行系统的体系结构，包括互联架构、缓存一致性<br/>架构的原理和实现。第7章介绍计算机I/O基本原理，包括PCIE、USB、SAS三大I/O体系。第8章介绍计算机<br/>是如何处理声音和图像的，包括3D渲染和图形加速原理架构和实现。第9章介绍大规模并行计算、超级计算机原<br/>理和架构，以及可编程逻辑器件（如FPGA等）的原理和架构。第10章介绍现代计算机操作系统基本原理和架构，<br/> 本书共分为12章。第1章介绍数字计算机的设计思路，制作一个按键计算器，在这个过程中逐步理解数字计<br/>算机底层原理。第2章在第1章的基础上，改造按键计算器，实现能够按照编好的程序自动计算，并介绍对应的处<br/>理器内部架构概念。第3章介绍电子计算机的发展史，包括芯片制造等内容。第4章介绍流水线相关知识，包括流<br/>水线、分支预测、乱序执行、超标量等内容。第5章介绍计算机程序架构，理解单个、多个程序如何在处理器上编<br/>译、链接并*终运行的过程。第6章介绍缓存以及多处理器并行执行系统的体系结构，包括互联架构、缓存一致性<br/>架构的原理和实现。第7章介绍计算机I/O基本原理，包括PCIE、USB、SAS三大I/O体系。第8章介绍计算机<br/>是如何处理声音和图像的，包括3D渲染和图形加速原理架构和实现。第9章介绍大规模并行计算、超级计算机原<br/>理和架构，以及可编程逻辑器件（如FPGA等）的原理和架构。第10章介绍现代计算机操作系统基本原理和架构，<br/>包括内存管理、任务调度、中断管理、时间管理等架构原理。第11章介绍现代计算机形态和生态体系，包括计算、<br/>网络、存储方面的实际计算机产品和生态。第12章介绍机器学习和人工智能底层原理和架构实现。<br/><br/> 本书适合所有IT行业从业者阅读，包括计算机（PC/服务器/手机/嵌入式）软硬件及云计算/大数据/人工<br/>智能等领域的研发、架构师、项目经理、产品经理、销售、售前。本书也同样适合广大高中生科普之用，另外计算<br/>机相关专业本科生、硕士生、博士生同样可以从本书中获取与课程教材截然不同的丰富营养。<br/><br/>
</p>]<p><h2>内容简介</h2></p>[<p>计算机，已经无处不在，你走到任何位置，都会有成千上万各种类型的“计算机”围绕着你，小到各种移动设备，大到飞机火车，都是由各种计算机控制并运转。你可曾想过这些计算机是怎么运作的？一个字节是怎么产生又是怎么消亡的？网络是如何连接一切的？人工智能到底是什么？……<br/>冬瓜哥其人，喜钻研，擅用与科班教材截然不同的方式把计算机原理细细分解，娓娓道来。这本书如此通俗，以至于假设当代文明毁灭之后，下一个文明从地壳中找到这本书，按照书中所讲即可迅速建立起计算机体系，极大推动下一个文明的进程……<br/><br/> </p>]<p><h2>作者简介</h2></p>[<p>冬瓜哥（张冬），现任某半导体公司系统架构师，喜钻研，著有《大话存储》系列图书。</p>]<p><h2>目录</h2></p>
    开篇?苦想计算机——以使用者的名义第1章?电控开关——计算机世界的基石1.1　十余年的迷惑    41.2　从1 1=2说起    41.2.1　用电路实现1 1=2    61.2.2　或门    61.2.3　与门    71.2.4　非门和与非门    71.2.5　异或门    71.2.6　1位加法器    81.2.7　全手动1位加法机    101.2.8　实现多位加法器    101.2.9　电路的时延    131.2.10　新世界的新规律    131.2.11　先行/并行进位    141.2.12　电路化简和变换    151.3　我们需要真正可用的计算器    161.3.1　产生记忆    171.3.2　解决按键问题    181.3.3　数学的懵懂    221.3.4　**次理解数学    251.3.5　**次理解语义    271.3.6　七段显示数码管    301.3.7　野路子乘法器    311.3.8　科班乘法器    351.3.9　数据交换器Crossbar    361.3.10　多媒体声光按键转码器    391.3.11　**次驾驭时间    411.4　信息与信号    441.4.1　录制和回放    441.4.2　振动和信号    491.4.3　低通滤波    521.4.4　高通滤波    561.4.5　带通滤波    591.4.6　带阻滤波    591.4.7　傅里叶变换    591.4.8　波动与电磁波    601.4.9　载波、调制与频分复用    621.5　完整的计算器    681.5.1　用时序控制增强用户体验    691.5.2　用MUX来实现Crossbar    711.5.3　奇妙的FIFO队列    731.5.4　同步/异步FIFO     761.5.5　全局共享FIFO     771.5.6　多路仲裁     781.5.7　交换矩阵     791.5.8　时序问题的产生与触发器    841.5.9　擒纵机构与触发器    861.5.10　擒纵机构与晶振    871.5.11　Serdes与MUX/DEMUX    901.5.12　计算离不开数据传递    901.5.13　几个专业概念的由来    911.5.13.1?输入设备    911.5.13.2?输出设备    911.5.13.3?计算单元/运算器    911.5.13.4?控制单元和传递通路    911.5.13.5?反馈    911.5.13.6?运算/计算    941.5.13.7?数据通路和控制通路    941.5.13.8?组合逻辑和时序逻辑    941.5.13.9?寄存器/ Latch/触发器/锁存器    941.5.13.10?存储器    941.5.13.11?地址/指针    951.5.13.12?写使能信号    951.6　多功能计算器    95算术逻辑单元    96第2章?解脱人手——程序控制计算机2.1　从累积计算说起    982.2　自动执行    1012.2.1　将操作方式的描述转化为指令    1022.2.2　实现那只鱿鱼——控制通路及部件    1042.2.3　动起来吧！——时序通路及部件    1082.2.4　半自动执行！——你得推着它跑    1122.2.5　全自动受控执行！——不用扬鞭自奋蹄！    1132.2.6　NOOP指令    1152.2.7　利用边沿型触发器搭建电路    1162.2.8　分步图解指令的执行过程    1212.2.9　判断和跳转    1232.2.10　再见，章鱼先生！    1262.3　更高效的执行程序    1282.3.1　利用循环缩减程序尺寸    1282.3.2　实现更多方便的指令    1312.3.3　多时钟周期指令    1332.3.4　微指令和微码    1362.3.5　全局地址空间    1382.3.6　多端口存储器    1382.3.7　多级缓存与CPU    1392.3.8　数据遍布各处    1422.3.9　降低数据操作粒度    1452.3.10　取指令/数据缓冲加速    147第3章?开关的进化——从机械到芯片3.1　从薄铁片到机械计算机    1503.1.1　算盘和计算尺    1503.1.2　不可编程手动机械十进制计算机    1513.1.3　可编程自动机械十进制计算机    1523.1.4　可编程自动电动机械二进制计算机    1563.1.5　可编程自动全电动二进制计算机    1623.2　电子管时代    1663.2.1　二极电子管    1663.2.2　三极电子管    1703.2.3　AM广播革命    1723.2.4　电子管计算机    1743.2.5　石头会唱歌    1773.3　固态革命——晶体管    1793.3.1　P/N结与晶体管    1813.3.2　场效应管（FET）    1833.3.3　MOSFET    1853.3.4　cMOS    1863.3.5　晶体管计算机    1873.4　制造工艺革命——集成电路    1903.4.1　量产晶体管    1903.4.2　跟冬瓜哥学做P/N结蛋糕    1923.4.3　提升集成度    1963.4.4　芯片内的深邃世界    1973.4.5　cMOS集成电路工艺概述    2003.4.6　cMOS工艺步骤概述    2033.4.7　cMOS工艺详细步骤    2063.4.7.1　热氧化    2073.4.7.2　氮化硅积淀    2073.4.7.3　浅槽隔离蚀刻    2083.4.7.4　pMOS和nMOS生成    2093.4.7.5　触点电极的生成    2133.4.7.6　通孔和支撑柱（via）的生成    2143.4.7.7　**层导线连接    2163.4.7.8　第二层导线连接    2163.4.7.9　表面钝化    2173.4.8　半导体工艺的瓶颈    2203.4.8.1　寄生电容    2203.4.8.2　静态/动态功耗    2213.4.8.3　栅氧厚度和High-K材料    2223.4.8.4　导线连接和Low-K材料    2223.4.8.5　驱动能力及时延    2223.4.8.6　时钟树    2243.4.9　集成电路计算机    2243.4.10　微处理器计算机    2273.4.11　暴力拆解奔三CPU    2303.5　存储器：不得不说的故事    2323.5.1　机械存储器    2333.5.1.1　声波/扭力波延迟线（Delay Line）    2333.5.1.2　磁鼓存储器（Drum）    2343.5.1.3　磁芯存储器（Core）    2353.5.2　电子存储器    2383.5.2.1　静态随机存储器（SRAM）    2383.5.2.2　动态随机存储器（DRAM）    2413.5.2.3　Flash闪存    2463.5.2.4　只读存储器（ROM）    2483.5.3　光存储器    2483.5.3.1　光盘是如何存储数据的    2483.5.3.2　压盘与刻盘的区别    2503.5.3.3　光盘表面微观结构    2503.5.3.4　多层记录    2513.5.3.5　激光头的秘密    2513.5.3.6　蓝光光盘简介    2523.5.4　不同器件担任不同角色    2533.5.4.1　寄存器和缓存    2533.5.4.2　主运行内存/主存    2533.5.4.3　Scratchpad RAM    2543.5.4.4　内容寻址内存CAM/TCAM    2543.5.4.5　外存    257第4章?电路执行过程的进化——流水线、分支预测、乱序执行与多发射    4.1　大话流水线    2604.1.1　不高兴的译码器    2604.1.2　思索流水线    2634.1.2.1　流水线的本质是并发    2634.1.2.2?不同时延的步骤混杂    2644.1.2.3　大话队列    2664.1.2.4?流水线的应用及优化    2684.2　优化流水线    2704.2.1　拆分慢速步骤    2704.2.2　放置多份慢速部分    2724.2.3　加入缓冲队列    2734.2.4　图解五级流水线指令执行过程    2734.3　流水线冒险    2734.3.1　访问冲突与流水线阻塞    2784.3.2　数据依赖与数据前递    2814.3.3　跳转冒险与分支预测    2854.4　指令的动态调度    2934.4.1　结构相关与寄存器重命名    2934.4.2　保留站与乱序执行    2954.4.3　分步图解乱序执行    2974.4.4　重排序缓冲与指令顺序提交    3194.5　物理并行执行    3204.5.1　超标量和多发射    3204.5.2　VLIW超长指令字    3224.5.3　SIMD单指令多数据    3224.6　小结    326第5章?程序世界——从机器码到操作系统5.1　基本的数据结构    3305.1.1?数组    3305.1.2　数据类型与ASCII码    3315.1.3　结构体    3335.1.4　数据怎么摆放很重要    3335.2　高级语言    3355.2.1　简单的声明和赋值    3355.2.2　编译和编译器    3365.2.3　向编译器描述数据的编排方式    3375.2.4　高级语言编程小试牛刀    3395.2.5　人脑编译忆苦思甜    3415.3　浮点数及浮点运算    3425.3.1　数值范围和精度    3425.3.2　浮点数的用处和表示方法    3435.3.3　浮点数的二进制表示    3445.3.3.1?二进制浮点数转十进制小数    3445.3.3.2?十进制小数转二进制浮点数    3455.3.3.3?负指数和0的表示    3465.3.3.4?无穷与非规格化数的表示    3465.3.4　浮点数运算挺费劲    3475.3.5　浮点数的C语言声明    3495.3.6　十六进制表示法    3495.4　程控多媒体计算机    3505.4.1　键盘是前提    3505.4.2　搜索并显示    3515.4.3　实现简易计算器    3545.4.4　录入和保存    3555.4.5　简易文件系统    3565.4.6　计时/定时    3605.4.7　发声控制    3675.4.8　图像显示    3695.4.9　网络聊天    3725.5　程序社会    3765.5.1　函数和调用    3775.5.2　设备驱动程序    3815.5.3　函数之间的联络站    3885.5.4　库和链接    3975.5.4.1?静态库和静态链接    3995.5.4.2?头文件    4045.5.4.3?API和SDK    4065.5.4.4?动态库和动态链接    4095.5.4.5?库文件/可执行文件的格式    4105.5.5　程序的执行和退出    4125.5.5.1?初步解决地址问题    4135.5.5.2?更好的人机交互方式    4135.5.5.3?程序的退出    4145.5.5.4?使用外部设备和内存    4165.5.6　多程序并发执行    4175.5.6.1?利用时钟中断来切换线程    4185.5.6.2?更广泛地使用中断    4215.5.6.3?虚拟地址空间与分页    4215.5.6.4?虚拟与现实的边界——系统调用    4265.5.7　呼唤操作系统    428第6章?多处理器微体系结构——多核心与缓存6.1　从超线程到多核心    4306.1.1　超线程并行    4306.1.2　多核心/多CPU并行    4336.1.3　idle线程    4346.1.4　乱序执行还是SMT？    4356.1.5　逆超线程？    4366.1.6　线程与进程    4366.1.7　多核心访存基本拓扑    4376.2　缓存十九式    4426.2.1　缓存是分级的    4426.2.2　缓存是透明的    4426.2.3　缓存的容量、频率和延迟    4436.2.4　私有缓存和共享缓存    4436.2.5　Inclusive模式和Exclusive模式    4446.2.6　Dirty标记位和Valid标记位    4446.2.7　缓存行    4456.2.8　全关联/直接关联/组关联    4466.2.9　用虚拟地址查缓存    4516.2.10　缓存的同名问题    4536.2.11　缓存的别名问题    4536.2.12　页面着色    4556.2.13　小结及商用CPU的缓存模式    4576.2.14　缓存对写入操作的处理    4586.2.15　Load/Stor Queue与Stream Buffer    4596.2.16　非阻塞缓存与MSHR    4606.2.17　缓存行替换策略    4626.2.18　i_Cache/d_Cache/TLB_ Cache    4636.2.19　对齐和伪共享    4656.3　关联起来，为了一致性    4656.3.1　Crossbar交换矩阵    4666.3.2　Ring    4726.3.3?NoC     4756.3.4　众核心CPU    4786.3.5　多核心程序执行过程回顾    4816.3.6　在众核心上执行程序    4826.4　存储器在网络中的分布    4846.4.1　CPU片内访存网络与存储器分布    4876.4.2　CPU片外访存网络    4896.4.2.1　全总线拓扑及南桥与北桥    4906.4.2.2　AMD Athlon北桥    4926.4.2.3　常用网络拓扑及UMA/NUMA    4946.4.2.4　AMD Opteron北桥    4976.4.3　参悟全局共享内存架构    4996.4.4　访存网络的硬分区    5016.5　QPI片间互联网络简介    5026.5.1　QPI物理层与同步异步通信原理    5036.5.2　QPI链路层网络层和消息层    5056.5.3　QPI的初始化与系统启动    5076.5.3.1　链路初始化和拓扑发现    5076.5.3.2　系统启动    5076.5.4　QPI的扩展性    5096.6　基于QPI互联的高端服务器架构一览    5106.6.1　某32路CPU高端主机    5106.6.2　DELLEMC的双层主板QPI互联    5116.6.3　IBM x3850/3950 X5/X6主机    5116.6.4　HP Superdome2主机    5156.6.5　Fujitsu PQ2K主机    5186.7　理解多核心访存时空一致性问题    5206.7.1　访存空间一致性问题    5206.7.2　访存时间一致性问题    5216.7.2.1　延迟到达导致的错乱    5216.7.2.2　访问冲突导致的错乱    5216.7.2.3　提前执行导致的错乱    5226.7.2.4　乱序执行导致的错乱    5226.8　解决多核心访存时间一致性问题    5236.8.1　互斥访问    5236.8.2　让子弹飞    5266.8.3　硬件原生保证的基本时序    5276.8.4　解决延迟到达错乱问题    5296.8.5　解决访问冲突错乱问题    5306.8.6　解决提前执行测错乱问题    5306.8.7　解决乱序执行错乱问题    5316.8.8　小结    5316.9　解决多核心访存空间一致性问题    5336.9.1　基于总线监听的缓存一致性实现    5336.9.1.1　Snarfing/Write Sync方式    5336.9.1.2　Write Invalidate方式    5346.9.2　推导MESIF状态机    5356.9.3　MOESI状态机    5406.9.4　结合MESIF协议进一步理解锁和屏障    5406.9.5　结合MESIF深刻理解时序一致性模型    5456.9.5.1　终极一致性（UC）    5456.9.5.2　严格一致性（SC）    5456.9.5.3　顺序一致性（SEC）    5456.9.5.4　处理器一致性（PC）    5466.9.5.5　弱一致性（WC）    5466.9.6　缓存行并发写优化    5466.9.7　Cache Agent的位置    5476.9.8　基于共享总线的嗅探过滤机制    5486.9.8.1　bitmap粗略过滤    5496.9.8.2　向量bitmap精确过滤    5496.9.8.3　布隆过滤器与散列采样    5506.9.8.4　JETTY filter    5516.9.8.5　流寄存器式过滤器    5536.9.8.6　带计数器的SR过滤器    5546.9.8.7　蓝色基因/P中的嗅探过滤器    5546.9.9　基于分布式访存网络的缓存一致性实现    5556.9.9.1　分布式网络对CC机制的影响    5576.9.9.2　多级缓存和多CPU对CC机制的影响    5586.9.9.3?即便无锁也要保证一致    5586.9.10　分布式网络下的嗅探过滤机制    5596.9.10.1　在LLC中增设bitmap向量过滤片内广播    5596.9.10.2　Ring网络的三种嗅探方式    5616.9.10.3　增设远程目录过滤片外广播    5626.9.10.4　利用HA代理片内CC事务    5656.9.10.5　小结    5696.9.10.6　在网络路径上实施嗅探过滤    5706.9.11　缓存一致性实现实际案例    5716.9.11.1　Intel Blackford北桥CC实现    5726.9.11.2　AMD Opteron 800平台CC实现    5736.9.11.3　北桥与NC（Node Controller）    5756.9.11.4　Horus NC实现    5766.9.11.5　SGI Origin 2000 NC实现    5806.9.11.6　IBM PERCS超级计算机中的NC    5836.9.11.7　Intel CPU在QPI网络下的CC实现    5856.9.11.8　小结    588第7章?计算机I/O子系统7.1　计算机I/O的基本套路    5937.1.1　Programmed IO Polling模式    5937.1.2　DMA 中断模式    5987.1.3　DMA与缓存一致性    6007.1.4　Scatter/Gather List（SGL）    6017.1.5　使用队列提升I/O性能    6017.1.6　固件/Firmware    6047.1.6.1?固件与OS的区别与联系    6057.1.6.2?固件的层次    6057.1.6.3?固件的格式    6057.1.6.4?固件存在哪    6057.1.6.5?固件如何加载运行    6067.1.7　网络I/O基本套路    6067.1.8　接入更多外部设备    6107.1.9　一台完整计算机的全貌    6147.2　中断处理    6167.3　网络通信系统    6197.3.1　OSI七层标准模型    6207.3.1.1?应用层    6207.3.1.2?表示层    6207.3.1.3?会话层    6217.3.1.4?传输层    6217.3.1.5?网络层    6247.3.1.6?链路层    6267.3.1.7?物理层    6277.3.1.8?传送层    6277.3.1.9?小结    6297.3.2　底层信号处理系统    6307.3.2.1?AC耦合电容及N/Mbit编码    6307.3.2.2?加扰的作用    6347.3.2.3?各种线路编码    6367.3.2.4?各种模拟调制技术    6377.3.2.5?频谱宽度与比特率    6417.3.2.6?数字信号处理与数字滤波    6467.3.3　以太网——高速通用非访存式后端外部网络    6477.3.3.1?以太网的网络层    6477.3.3.2?以太网的链路层和物理层    6527.3.3.3?以太网I/O控制器    6527.4　典型I/O网络简介    6527.4.1?PCIE——高速通用访存式前端I/O网络    6547.4.1.1?PCI网络拓扑及数据收发过程    6547.4.1.2?PCI设备的配置空间    6567.4.1.3?PCI设备的枚举和配置    6587.4.1.4?PCI设备寄存器的物理地址分配和路由    6637.4.1.5?中期小结    6647.4.1.6?PCIE网络拓扑及数据收发过程    6657.4.1.7?PCIE网络的层次模型    6697.4.1.8?NTB非透明桥    6857.4.1.9?PCIE Switch内部    6927.4.1.10?在PCIE网络中传递消息    6977.4.1.11?在PCI网络中传递中断信号    6987.4.1.12?在PCIE网络中传递中断信号    7007.4.1.13?MSI/MIS-X中断方式    7017.4.1.14?PCIE体系中的驱动程序层次    7067.4.1.15?小结    7087.4.2　USB——中速通用非访存式后端I/O网络    7097.4.2.1?USB网络的基本拓扑    7127.4.2.2?USB设备的枚举和配置    7147.4.2.3?USB网络协议栈    7197.4.2.4?USB网络上的数据包传送    7227.4.2.5?USB网络的层次模型    7287.4.2.6?小结    7297.4.3　SAS——高速专用非访存式后端I/O网络    7307.4.3.1?SAS网络拓扑及设备编号规则    7337.4.3.2?SAS网络中的Order Set一览    7347.4.3.3?SAS的链路初始化和速率协商    7347.4.3.4?SAS网络的初始化与设备枚举    7437.4.3.5?SAS和SCSI的Host端协议栈    7537.4.3.6?形形色色的登记表    7617.4.3.7?SAS网络的数据传输方式    7787.4.3.8?SAS网络的层次模型    7837.4.3.9?SAS控制器内部架构    7897.4.3.10?SAS SXP内部架构    7977.5　本章小结    797第8章?绘声绘色——计算机如何处理声音和图像8.1　声音处理系统    8028.1.1　让蜂鸣器说话    8028.1.2　音乐是可以被勾兑出来的    8038.1.2.1?可编程音符生成器PSG    8048.1.2.2?音乐合成器    8058.1.2.3?FM合成及波表合成    8098.1.3　声卡发展史及架构简析    8128.1.4　与发声控制相关的Host端角色    8178.1.5　让计算机成为演奏家    8328.1.6　独立声卡的没落    8328.2　图形处理系统    8428.2.1　用声音来画图    8468.2.2　文字模式    8498.2.2.1?向量文本模式显示    8498.2.2.2?用ROM存放字形库    8528.2.2.3?点阵文字显示模式    8528.2.2.4?单色显示适配器    8558.2.2.5?点阵作图与ASCII Art    8568.2.3　图形模式    8578.2.3.1?Color Graphics Adapter（CGA）    8578.2.3.2?Enhanced Graphics Adapter（EGA）    8608.2.3.3?Video BIOS ROM的引入    8618.2.3.4?Video Graphics Array（VGA）    8638.2.3.5?VGA的后续    8648.2.3.6?当代显卡的图形和文字模式    8648.2.4　2D图形及其渲染流程    8648.2.4.1?2D图形加速卡PGC    8668.2.4.2?2D图形模型的准备    8728.2.4.3?对模型进行渲染    8748.2.4.4?矢量图和bitmap    8758.2.4.5?顶点、索引和图元    8768.2.4.6?2D图形动画    8768.2.4.7?坐标変换及矩阵运算    8788.2.4.8?2D图形渲染流程小结    8808.2.4.9?2D绘图库以及渲染加速    8808.2.5　3D图形模型和表示方法    8858.2.5.1?3D模型的表示    8868.2.5.2?顶点的4个基本属性    8898.2.6　3D图形渲染流程    8938.2.6.1?顶点坐标变换阶段/Vertex Transform    8938.2.6.2?顶点光照计算阶段/Vertex Lighting    8978.2.6.3?栅格化阶段/Rasterization    8998.2.6.4?像素着色阶段/Pixel Shading    9008.2.6.5?遮挡判断阶段/Testing    9098.2.6.6?混合及后处理阶段/Blending    9148.2.6.7?3D渲染流程小结    9148.2.7　典型的3D渲染特效简介    9158.2.7.1?法线贴图（Normal Map）    9168.2.7.2?曲面细分与置换贴图（Tessellation）    9208.2.7.3?视差/位移贴图（Parallax Map）    9228.2.7.4?物体投影（Shadow）    9258.2.7.5?抗锯齿（Anti-Aliasing）    9268.2.7.6?光照控制纹理（Light Mapping）    9318.2.7.7?纹理动画（Texture Animation）    9348.2.8　当代3D游戏制作过程    9368.2.9　3D图形加速渲染    9378.2.9.1?3D图形渲染管线回顾    9398.2.9.2?固定渲染管线3D图形加速    9408.2.9.3?可编程渲染管线3D图形加速    9438.2.9.4?Unified可编程3D图形加速    9558.2.9.5?深入AMD R600 GPU内部执行流程    9558.2.10　3D绘图API 及软件栈    9638.2.10.1?GPU内核态驱动及命令的下发    9658.2.10.2?GPU用户态驱动及命令的翻译    9668.2.10.3?久违了OpenGL与Direct3D    9698.2.10.4?Windows图形软件栈    9738.2.11　3D图形加速卡的辉煌时代    9748.2.11.1?街机/家用机/手机上的GPU    9748.2.11.2?SGI Onyx超级图形加速工作站    9788.2.11.3?S3 ViRGE时代    9798.11.2.4?3dfx Voodoo时代    9808.2.11.5?Nvidia和ATI时代    9858.3　结语和期盼    991
