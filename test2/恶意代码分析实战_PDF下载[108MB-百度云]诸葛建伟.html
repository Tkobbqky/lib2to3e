恶意代码分析实战 PDF下载 诸葛建伟 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712122468
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712122468
<p>书名:恶意代码分析实战</p><p>作者:诸葛建伟</p><p>页数:704</p><p>定价:¥128.0</p><p>出版社:电子工业出版社</p><p>出版日期:2014-04-01</p><p>ISBN:9787121224683</p><p><h2>相关资料</h2></p>[<p>一本优秀的恶意代码速成教程。<br/>
　　dino dai zovi，自由安全咨询师<br/>
　　一本最为全面的恶意代码分析技术指南，覆盖了所有恶意代码分析所需的关键技术，帮助你理解最新恶意代码带来的技术挑战。<br/>
　　chris eagle，美国海军研究生院，计算机科学系高级讲师<br/>
　　一本恶意代码分析的实践入门指南，我把这本书推荐给所有希望解剖windows恶意代码的读者。<br/>
　　— ilfak guilfanov，ida pro创始人<br/>
　　一本恶意代码分析的优秀指南，所有章节都包含有详细的技术解释和动手实践案例教程，让你能够立即面对真实的恶意代码。<br/>
　　— sebastian porst，google软件工程师<br/>
　　本书为各个技术层次上的读者带来逆向工程方法，提供了一大堆覆盖各种技术并且容易访问的实践案例，将带领你更加深入地理解逆向工程的艺术与科学。我强烈推荐本书，无论是新手还是领域专家。<br/>
　　— danny quist，博士，offensive computing创始人<br/>
　　如果你只要读一本恶意代码的书籍，或是希望进入到恶意代码分析师的世界，就来看这本书吧！<br/>
　　— patrick engbretson，达科他州立大学教授，the basics of hacking and pen testing一书的作者<br/>
　　为软件安全或入侵检测系统等研究生级别高级课程提供很好的课程资料，实践案例对学生学习逆向工程方法、恶意代码分析和理解等方面具有特殊的价值。<br/>
　　— sal stolfo，哥伦比亚大学教授<br/>
<br/></p>]<p><h2>本书特色</h2></p>[<p>
《恶意代码分析实战》是一本内容全面的恶意代码分析技术指南，其内容兼顾理论，重在实践，从不同方面为读者讲解恶意代码分析的实用技术方法。
　　《恶意代码分析实战》分为21章，覆盖恶意代码行为、恶意代码静态分析方法、恶意代码动态分析方法、恶意代码对抗与反对抗方法等，并包含了shellcode分析，c++恶意代码分析，以及64位恶意代码分析方法的介绍。本书多个章节后面都配有实验并配有实验的详细讲解与分析。通过每章的介绍及章后的实验，本书一步一个台阶地帮助初学者从零开始建立起恶意代码分析的基本技能。
　　《恶意代码分析实战》获得业界的一致好评，ida pro的作者ilfak guilfanov这样评价本书：“一本恶意代码分析的实践入门指南，我把这本书推荐给所有希望解剖windows恶意代码的读者”。
　　《恶意代码分析实战》的读者群主要是网络与系统安全领域的技术爱好者与学生及恶意代码分析研究方面的安全从业人员。

                                        </p>]<p><h2>内容简介</h2></p>[<p>不管你是否有恶意代码分析的背景和经验，《恶意代码分析实战》极其丰富的内容都将使你获益匪浅。
　　《恶意代码分析实战》教你如何、以及何时使用恶意代码分析技术，深入掌握恶意代码分析工具的核心功能，从而达到准确诊断、及时突破、快速响应的效果。
　　《恶意代码分析实战》一经问世，便赢来业内好评如潮，被业内人士一致推荐为入门、晋级的权威读本。
　　权威，详尽，经典——每一位认真学习过《恶意代码分析实战》的读者，必将在恶意代码分析的专业技能上获得巨大的提升。
</p>]<p><h2>目录</h2></p>
    第0章 恶意代码分析技术入门 0.1 恶意代码分析目标 0.2 恶意代码分析技术 0.2.1 静态分析基础技术 0.2.2 动态分析基础技术 0.2.3 静态分析高级技术 0.2.4 动态分析高级技术 0.3 恶意代码类型 0.4 恶意代码分析通用规则 第 1篇 静态分析第1章 静态分析基础技术 1.1 反病毒引擎扫描：实用的**步 1.2 哈希值：恶意代码的指纹 1.3 查找字符串 1.4 加壳与混淆恶意代码 1.4.1 文件加壳 1.4.2 使用peid检测加壳 1.5 pe文件格式 1.6 链接库与函数 1.6.1 静态链接、运行时链接与动态链接 1.6.2 使用dependency walker工具探索动态链接函数 1.6.3 导入函数 1.6.4 导出函数 1.7 静态分析技术实践 1.7.1 potentialkeylogger.exe：一个未加壳的可执行文件 1.7.2 packedprogram.exe：穷途末路 1.8 pe文件头与分节 1.8.1 使用peview来分析pe文件 1.8.2 使用resource hacker工具来查看资源节 1.8.3 使用其他的pe文件工具 1.8.4 pe文件头概述 1.9 小结 1.10 实验 第2章 在虚拟机中分析恶意代码 2.1 虚拟机的结构 2.2 创建恶意代码分析机 2.2.1 配置vmware 2.2.2 断开网络 2.2.3 创建主机模式网络 2.2.4 使用多个虚拟机 2.3 使用恶意代码分析机 2.3.1 让恶意代码连接互联网 2.3.2 连接和断开外围设备 2.3.3 拍摄快照 2.3.4 从虚拟机传输文件 2.4 使用vmware进行恶意代码分析的风险 2.5 记录/重放：重复计算机运行轨迹 2.6 小结 第3章 动态分析基础技术 3.1 沙箱：简便但粗糙的方法 3.1.1 使用恶意代码沙箱 3.1.2 沙箱的缺点 3.2 运行恶意代码 3.3 进程监视器 3.3.1 进程监视器的显示 3.3.2 进程监视器中的过滤 3.4 使用进程浏览器（process explorer）来查看进程 3.4.1 进程浏览器的显示 3.4.2 使用验证选项 3.4.3 比较字符串 3.4.4 使用依赖遍历器（dependency walker） 3.4.5 分析恶意文档 3.5 使用regshot来比较注册表快照 3.6 模拟网络 3.6.1 使用apatedns 3.6.2 使用netcat进行监视 3.7 使用wireshark进行数据包监听 3.8 使用inetsim 3.9 基础动态分析工具实践 3.10 小结 3.11 实验 第 2篇 静态分析高级技术篇第4章 x86反汇编速成班 4.1 抽象层次 4.2 逆向工程 4.3 x86体系结构 4.3.1 内存 4.3.2 指令 4.3.3 操作码和字节序 4.3.4 操作数 4.3.5 寄存器 4.3.6 简单指令 4.3.7 栈 4.3.8 条件指令 4.3.9 分支指令 4.3.10 重复指令 4.3.11 c语言主函数和偏移 4.3.12 更多信息：intel x86 architecture manual 4.4 小结 第5章 ida pro 5.1 加载一个可执行文件 5.2 ida pro接口 5.2.1 反汇编窗口模式 5.2.2 对分析有用的窗口 5.2.3 返回到默认视图 5.2.4 导航ida pro 5.2.5 搜索 5.3 使用交叉引用 5.3.1 代码交叉引用 5.3.2 数据交叉引用 5.4 分析函数 5.5 使用图形选项 5.6 增强反汇编 5.6.1 重命名位置 5.6.2 注释 5.6.3 格式化操作数 5.6.4 使用命名的常量 5.6.5 重新定义代码和数据 5.7 用插件扩展ida 5.7.1 使用idc脚本 5.7.2 使用idapython 5.7.3 使用商业插件 5.8 小结 5.9 实验 第6章 识别汇编中的c代码结构 6.1 全局与局部变量 6.2 反汇编算术操作 6.3 识别if语句 6.3.1 用ida pro图形化分析函数 6.3.2 识别嵌套的if语句 6.4 识别循环 6.4.1 找到for循环 6.4.2 找到while循环 6.5 理解函数调用约定 6.5.1 cdecl 6.5.2 stdcall 6.5.3 fastcall 6.5.4 压栈与移动 6.6 分析switch语句 6.6.1 if样式 6.6.2 跳转表 6.7 反汇编数组 6.8 识别结构体 6.9 分析链表遍历 6.10 小结 6.11 实验 第7章 分析恶意windows程序 7.1 windows api 7.1.1 类型和匈牙利表达法 7.1.2 句柄 7.1.3 文件系统函数 7.1.4 特殊文件 7.2 windows注册表 7.2.1 注册表根键 7.2.2 regedit 7.2.3 自启动程序 7.2.4 常用注册表函数 7.2.5 练习分析注册表操作代码 7.2.6 使用.reg文件的注册表脚本 7.3 网络api 7.3.1 伯克利兼容套接字 7.3.2 网络的服务器和客户端 7.3.3 wininet api 7.4 跟踪恶意代码的运行 7.4.1 dll 7.4.2 进程 7.4.3 线程 7.4.4 使用互斥量的进程间协作 7.4.5 服务 7.4.6 组件对象模型 7.4.7 异常：当事情出错时 7.5 内核与用户模式 7.6 原生api 7.7 小结 7.8 实验 第 3篇 动态分析高级技术篇第8章 动态调试 8.1 源代码级与汇编级的调试器 8.2 内核模式与用户模式调试 8.3 使用调试器 8.3.1 单步调试 8.3.2 单步跳过（stepping-over）和单步跳入（stepping-into） 8.3.3 用断点暂停执行 8.4 异常 8.4.1 首次和二次异常处理 8.4.2 常见异常 8.5 使用调试器修改可执行文件 8.6 修改可执行程序的实践 8.7 小结 第9章 ollydbg 9.1 加载恶意代码 9.1.1 打开一个可执行文件 9.1.2 附加调试器到一个运行程序 9.2 ollydbg的接口 9.3 内存映射 9.3.1 基地址重定位 9.4 查看线程和堆栈 9.5 执行代码 9.6 断点 9.6.1 软件断点 9.6.2 条件断点 9.6.3 硬件断点 9.6.4 内存断点 9.7 加载dll 9.8 跟踪 9.8.1 标准回溯跟踪 9.8.2 堆栈调用跟踪 9.8.3 运行跟踪 9.8.4 跟踪poison ivy 9.9 异常处理 9.10 修补 9.11 分析shellcode 9.12 协助功能 9.13 插件 9.13.1 ollydump 9.13.2 调试器隐藏插件 9.13.3 命令行 9.13.4 书签 9.14 脚本调试 9.15 小结 9.16 实验 第10章 使用windbg调试内核 10.1 驱动与内核代码 10.2 安装内核调试 10.3 使用windbg 10.3.1 从内存中读取 10.3.2 使用算术操作符 10.3.3 设置断点 10.3.4 列举模块 10.4 微软符号表 10.4.1 搜索符号 10.4.2 查看结构信息 10.4.3 配置windows符号表 10.5 内核调试实践 10.5.1 用户空间的代码 10.5.2 内核模式的代码 10.5.3 查找驱动对象 10.6 rootkit 10.6.1 rootkit分析实践 10.6.2 中断 10.7 加载驱动 10.8 windows vista、windows 7 和x64版本的内核问题 10.9 小结 10.10 实验 第 4篇 恶意代码功能篇第11章 恶意代码行为 11.1 下载器和启动器 11.2 后门（backdoor） 11.2.1 反向shell 11.2.2 远程控制工具 11.2.3 僵尸网络 11.2.4 远程控制工具与僵尸网络的比较 11.3 登录凭证窃密器 11.3.1 gina拦截 11.3.2 口令哈希转储 11.3.3 击键记录 11.4 存活机制 11.4.1 windows注册表 11.4.2 特洛伊木马化（trojanized）系统二进制文件 11.4.3 dll加载顺序劫持 11.5 提权 11.5.1 使用sedebugprivilege 11.6 隐藏它的踪迹——用户态的rootkit 11.6.1 iat hook 11.6.2 inline hook 11.7 小结 11.8 实验 第12章 隐蔽的恶意代码启动 12.1 启动器（launcher） 12.2 进程注入 12.2.1 dll注入 12.2.2 直接注入 12.3 进程替换 12.4 钩子（hook）注入 12.4.1 本地和远程钩子（hook） 12.4.2 使用钩子的击键记录器 12.4.3 使用setwindowshookex 12.4.4　目标线程 12.5 detours 12.6 apc注入 12.6.1 用户模式下apc注入 12.6.2 内核模式的apc注入 12.7 小结 12.8 实验 第13章 数据加密 13.1 分析加密算法的目的 13.2 简单的加密算法 13.2.1 凯撒密码 13.2.2 xor 13.2.3 其他一些简单的加密策略 13.2.4 base64 13.3 常见的加密算法 13.3.1 识别字符串和导入 13.3.2 查找加密常量 13.3.3 查找高熵值内容 13.4 自定义加密 13.4.1 识别自定义加密 13.4.2 攻击者使用自定义加密的优势 13.5 解密 13.5.1 自解密 13.5.2 手动执行解密函数 13.5.3 使用通用的解密规范 13.6 小结 13.7 实验 第14章 恶意代码的网络特征 14.1 网络应对措施 14.1.1 在原始环境中观察恶意代码 14.1.2 恶意行为的痕迹 14.1.3 opsec=操作安全性 14.2 安全地调查在线攻击者 14.2.1 间接性策略 14.2.2 获取ip地址和域名信息 14.3 基于内容的网络应对措施 14.3.1 使用snort进行入侵检测 14.3.2 深入观察 14.4 结合动态和静态分析技术 14.4.1 过度分析的危险 14.4.2 在众目睽睽下隐藏 14.4.3 理解周边代码 14.4.4 寻找网络操作代码 14.4.5 了解网络内容的来源 14.4.6 硬编码数据 vs. 临时数据 14.4.7 确定和利用编码步骤 14.4.8 创建特征 14.4.9 分析解析例程 14.4.10 针对多个元素 14.5 了解攻击者的意图 14.6 小结 14.7 实验 第 5篇 逆向工程第15章 对抗反汇编 15.1 何谓对抗反汇编技术 15.2 挫败反汇编算法 15.2.1 线性反汇编 15.2.2 面向代码流的反汇编 15.3 对抗反汇编技术 15.3.1 相同目标的跳转指令 15.3.2 固定条件的跳转指令 15.3.3 无效的反汇编指令 15.3.4 用ida pro对指令进行nop替换 15.4 混淆控制流图 15.4.1 函数指针问题 15.4.2 在ida pro中添加代码的交叉引用 15.4.3 滥用返回指针 15.4.4 滥用结构化异常处理 15.5 挫败栈帧分析 15.6 小结 15.7 实验 第16章 反调试技术 16.1 探测windows调试器 16.1.1 使用windows api 16.1.2 手动检测数据结构 16.1.3 系统痕迹检测 16.2 识别调试器的行为 16.2.1 int扫描 16.2.2 执行代码校验和检查 16.2.3 时钟检测 16.3 干扰调试器的功能 16.3.1 使用tls回调 16.3.2 使用异常 16.3.3 插入中断 16.4 调试器漏洞 16.4.1 pe头漏洞 16.4.2 outputdebugstring漏洞 16.5 小结 16.6 实验 第17章 反虚拟机技术 17.1 vmware 痕迹 17.1.1 绕过vmware痕迹的探测 17.1.2 探测内存痕迹 17.2 查找漏洞指令 17.2.1 使用red pill反虚拟机技术 17.2.2 使用no pill技术 17.2.3 查询i/o通信端口 17.2.4 使用str指令 17.2.5 反虚拟机的x86指令 17.2.6 在ida pro中高亮显示反虚拟机代码 17.2.7 使用scoopyng 17.3 调整设置 17.4 虚拟机逃逸 17.5 小结 17.6 实验 第18章 加壳与脱壳 18.1 剖析加壳 18.1.1 脱壳存根 18.1.2 加载可执行文件 18.1.3 解析导入函数表 18.1.4 尾部跳转 18.1.5 图示脱壳过程 18.2 识别加壳程序 18.2.1 加壳程序的标识 18.2.2 熵计算 18.3 脱壳选项 18.4 自动脱壳 18.5 手动脱壳 18.5.1 使用导入重构器重构导入表 18.5.2 查找oep 18.5.3 手动修复导入表 18.6 常见壳的技巧与窍门 18.6.1 upx 18.6.2 pecompact 18.6.3 aspack 18.6.4 petite 18.6.5 winupack 18.6.6 themida 18.7 不完全脱壳情况下的分析 18.8 加壳dll 18.9 小结 18.10 实验 第 6篇 高级专题第19章　shellcode分析 19.1 加载shellcode进行分析 19.2　位置无关代码 19.3　识别执行位置 19.3.1　使用call/pop指令 19.3.2　使用fnstenv指令 19.4 手动符号解析 19.4.1 在内存中找到kernel32.dll 19.4.2 解析pe文件导出数据 19.4.3 使用散列过的导出符号名 19.5 一个完整的hello world例子 19.6 shellcode编码 19.7 空指令雪橇 19.8　找到shellcode 19.9 小结 19.10 实验 第20章　c＋＋代码分析 20.1 面向对象的编程语言 20.1.1　this指针 20.1.2　重载与修饰 20.1.3　继承（inheritance）和函数重写（overriding） 20.2　虚函数和非虚函数 20.2.1　虚函数表的使用 20.2.2　识别虚函数表 20.3　创建和销毁对象 20.4　小结 20.5 实验 第21章 64位恶意代码 21.1　为什么需要64位恶意代码 21.2　x64架构上的差别 21.2.1　x64调用约定和栈使用上的差别 21.2.2　64位异常处理 21.3　在windows 64位上的windows 32位 21.4　恶意代码功能上的64位提示 21.5　小结 21.6 实验 附录a 常见windows函数列表 附录b 流行的恶意代码分析工具列表 附录c 实验作业参考解答 附录d　致青春，基础软件开发的中国故事 附录e syser操作入门
